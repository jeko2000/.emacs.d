#+TITLE: Emacs Configuration
#+AUTHOR: Johnny Ruiz
#+EMAIL: jeko2000@yandex.com
#+LANGUAGE: en
* Initial configuration
** Startup
   Increase garbage collection threshold and log a message with
   startup metrics
   #+begin_src emacs-lisp :tangle yes
(setq gc-cons-threshold (* 100 1024 1024))

(defun jr/display-startup-time ()
  (message "Emacs init finished after %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'jr/display-startup-time)
   #+end_src
** Basic GUI
   Remove GUI elements geared to mouse usage.
   #+begin_src emacs-lisp :tangle yes
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)

(setq visible-cursor nil
      inhibit-startup-message t
      initial-scratch-message "")

;; Column numbers
(column-number-mode)

;; Global font lock (syntax highlighting)
(global-font-lock-mode t)

;; Transient mode
(transient-mark-mode 1)
(setq
 ;; Determine if shift+arrow selection is allowed
 shift-select-mode nil
 ;; Determine if C-u C-SPC C-SPC should pop the mark again
 set-mark-command-repeat-pop t)
   #+end_src
** Themes
   The manual defines [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Custom-Themes.html][Custom Themes]] as a collections of settings that can
   be enabled or disabled as a unit. However, for this section the term
   =theme= refers to a =color theme=.
   Themes are loaded using the `load-theme' function. Yet, when this function is
   called multiple times within the same emacs session, it's possible for themes
   to inadvertently inherit settings from previously themes.

   The desired behavior is for any currently active custom theme to be disabled
   prior to loading a new theme.

   The following function, taken almost verbatim from [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's configuration]],
   first asks the user to select a theme from a list of currently available themes,
   then it disables all curently enabled custom themes before finally loading the
   chosen theme.
   #+begin_src emacs-lisp :tangle yes
(defun switch-theme (theme)
  "Load THEME after disabling all curently loaded themes."
  (interactive
   (list (intern (completing-read
                  "Load custom theme: "
                  ;; we pass a list of available themes as strings
                  (mapcar 'symbol-name (custom-available-themes))))))
  (dolist (enabled-theme custom-enabled-themes)
    (disable-theme enabled-theme))
  (load-theme theme 'no-confirm))
;; The `bind-key' macro is part of use-package which is loaded as part
;; of init.el
(bind-key "s-<f12>" 'switch-theme)
   #+end_src
*** Nord
    The [[https://www.nordtheme.com][Nord]] color theme is a dark bluish palette great for readibility.
    #+html: <p align="center"><a href="https://www.nordtheme.com/ports/emacs" target="_blank"><img src="https://raw.githubusercontent.com/arcticicestudio/nord-docs/develop/assets/images/ports/emacs/overview-go.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package nord-theme
  :if (display-graphic-p))
    #+end_src
    -----
*** Zenburn
    [[http://kippura.org/zenburnpage/][Zenburn]] is a low contrast theme originally written for Vim.
    #+html: <p align="center"><a href="http://kippura.org/zenburnpage/" target="_blank"><img src="http://kippura.org/i/zenburn.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package zenburn-theme
  :if (display-graphic-p))
    #+end_src
    -----
*** Solarized theme
    The [[https://github.com/bbatsov/solarized-emacs][Solarized colour theme]] is a port by [[https://github.com/bbatsov][Bozhidar Batsov (bbatsov)]] from
    the original [[http://ethanschoonover.com/solarized][Solarized theme by Ethan Schoonover]].
    #+html: <p align="center"><a href="http://ethanschoonover.com/solarized" target="_blank"><img src="https://raw.githubusercontent.com/altercation/solarized/master/img/solarized-vim.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package solarized-theme
  :if (display-graphic-p)
  :config
  (setq solarized-distinct-fringe-background t)
  (setq x-underline-at-descent-line t))
    #+end_src
    -----
*** E-Ink
    [[https://github.com/maio/eink-emacs][Low distraction, minimalistic color theme]] for Emacs emulating reading
    on E Ink devices by [[https://github.com/maio][Marian Schubert maio]].
    #+html: <p align="center"><a href="https://github.com/maio/eink-emacs" target="_blank"><img src="https://raw.githubusercontent.com/maio/eink-emacs/master/images/example.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package eink-theme
  :if (display-graphic-p))
    #+end_src
    -----
*** Material theme
    The [[https://github.com/cpaulik/emacs-material-theme][Material theme]] is based on the colors proposed by the [[http://www.google.com/design/spec/style/color.html#color-color-palette][Google
    Maerial Design]] put together by [[https://github.com/cpaulik/][Christoph Paulik cpaulik]]
    #+html: <p align="center"><a href="http://www.google.com/design/spec/style/color.html#color-color-palette" target="_blank"><img src="https://github.com/cpaulik/emacs-material-theme/blob/master/material-theme.png?raw=true"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package material-theme
  :if (display-graphic-p))
    #+end_src
    -----
*** Tango theme
    Implementation of the [[http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines][Tango Desktop project palette]] by [[https://github.com/juba][Julien Barnier juba]]
    #+html: <p align="center"><a href="https://github.com/juba" target="_blank"><img src="https://raw.githubusercontent.com/juba/color-theme-tangotango/master/screenshots/tangotango_elisp.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package tangotango-theme
  :if (display-graphic-p))
    #+end_src
    -----
*** Waher
    #+html: <p align="center"><a href="https://github.com/emacsfodder/emacs-waher-theme" target="_blank"><img src="https://camo.githubusercontent.com/b3d3d57f542d19104c0c20495bdf7864292920ec/68747470733a2f2f7261772e6769746875622e636f6d2f6a61736f6e6d32332f656d6163732d77616865722d7468656d652f6d61737465722f77616865722d7468656d652e706e67"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package waher-theme
  :if (display-graphic-p))
    #+end_src
*** Theme of choice
    #+begin_src emacs-lisp :tangle yes
(defvar jr/default-theme 'nord
  "Default theme to be loaded as part of the initial
configuration.")

(when (and (display-graphic-p)
           (member jr/default-theme (custom-available-themes)))
  (switch-theme jr/default-theme))
    #+end_src
** Fonts
   Current fonts of choice:
   #+begin_src emacs-lisp :tangle yes
(let ((available-fonts (font-family-list)))
  (cond
   ((member "Inconsolata" available-fonts)
    (set-face-attribute 'default nil :font "Inconsolata" :height 160))
   ((member "DejaVu Sans Mono" available-fonts)
    (set-face-attribute 'default nil :font "DejaVu Sans Mono" :height 140))))

(global-prettify-symbols-mode 1)
   #+end_src
** UTF-8 Encoding
#+begin_src emacs-lisp :tangle yes
;; Default to UTF-8
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+end_src

** Aliases
#+begin_src emacs-lisp :tangle yes
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Disabled commands
#+begin_src emacs-lisp :tangle yes
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+end_src
** Auto save mode
#+begin_src emacs-lisp :tangle yes
(setq auto-save-default t
      auto-save-timeout 2
      auto-save-interval 64
      auto-save-list-file-prefix
      (expand-file-name "auto-save-list/.saves-" user-emacs-directory)
      backup-by-copying t
      backup-directory-alist
      `((".*" . ,(expand-file-name "backups" user-emacs-directory)))
      make-backup-files t
      version-control t
      delete-old-versions t
      delete-by-moving-to-trash t
      kept-old-versions 12
      kept-new-versions 12)
#+end_src
** Basic editing
#+begin_src emacs-lisp :tangle yes
(setq-default
 indent-tabs-mode nil
 indicate-empty-lines t
 truncate-lines t
 sentence-end-double-space nil)
#+end_src
** Basic buffer configuration
#+begin_src emacs-lisp :tangle yes
(setq uniquify-buffer-name-style 'forward)
(setq echo-keystrokes 0.5
      enable-recursive-minibuffers t)
#+end_src
** Auto compression mode
#+begin_src emacs-lisp :tangle yes
(auto-compression-mode t)
#+end_src
** Recursion variables
   From [[info:eintr#Loops%20&%20Recursion][info:eintr#Loops & Recursion]]

   #+begin_src emacs-lisp :tangle yes
(setq max-specpdl-size 20000
      max-lisp-eval-depth 30000)
   #+end_src
** Quit emacs
   Let's make it a bit harder to quit out of emacs
   #+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x C-c") nil)
(global-set-key (kbd "C-x r q") 'save-buffers-kill-terminal)
   #+end_src
* Non-programming packages
** exec-path-from-shell
   [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] ensures environment variables in Emacs match
   those in the shell.

   This is particulayl useful in macOS, where the a graphical Emacs
   instance only inherits the default environment variables.
   #+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :when (eq system-type 'darwin)
  :demand t
  :config
  (setq exec-path-from-shell-variables '("PATH" "MANPATH" "JAVA_HOME"))
  (exec-path-from-shell-initialize))
   #+end_src
** delight
   [[https://www.emacswiki.org/emacs/DelightedModes][Delight]] customizes how major and minor modes appear in the
   ModeLine. Furthermoore, =use-package= supports [[https://github.com/jwiegley/use-package#diminishing-and-delighting-minor-modes][diminishing modes]]
   via the =:delight= keyword.

   #+begin_src emacs-lisp :tangle yes
(use-package delight
  :demand t
  :config
  (delight '((abbrev-mode " Abv" abbrev)
             (auto-fill-function nil t)
             (auto-fill-mode nil t)
             (eldoc-mode "eldoc" eldoc)
             (emacs-lisp-mode "Elisp" :major)
             (org-agenda-mode "Agenda" :major))))
   #+end_src
** subword
   [[http://wikemacs.org/wiki/Subword-mode][Subword]] mode allows navigation commands to be aware of words in
   [[https://en.wikipedia.org/wiki/Camel_case][camelCase]].
   #+begin_src emacs-lisp :tangle yes
(use-package subword
  :delight
  :config
  (global-subword-mode 1))
   #+end_src
** Winner mode
   [[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] allows to 'undo' and 'redo' on window configurations.
   #+begin_src emacs-lisp :tangle yes
(use-package winner
  :defer 10
  :bind (("C-c <left>" . winner-undo)
         ("C-c <right>" . winner-redo))
  :config
  (winner-mode 1))
   #+end_src
** Ace jump mode
   [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] exposes functionality to quickly move the cursor.
   #+begin_src emacs-lisp :tangle yes
(use-package ace-jump-mode
  :bind (("C-S-s" . ace-jump-mode)
         ("s-s" . ace-jump-mode)))
   #+end_src
** Password store
   Password store allows to you to interface with the [[https://www.passwordstore.org/][pass]] password
   manager.
   #+begin_src emacs-lisp :tangle yes
(use-package password-store
  :if (file-exists-p "~/.password-store")
  :bind ("C-c s c" . password-store-copy))
   #+end_src

** Recentf
   [[https://www.emacswiki.org/emacs/RecentFiles][Recent Files]] builds a list of recent files for easy access.
   #+begin_src emacs-lisp :tangle yes
(use-package recentf
  :defer 10
  :config
  (recentf-mode 1)
  (setq recentf-max-saved-items 100))
   #+end_src

** Tramp
   [[https://www.emacswiki.org/emacs/TrampMode][TRAMP]] stands for Transparent Remote Access, Multiple Protocols. It
   allows access to remote files.
   #+begin_src emacs-lisp :tangle yes
(use-package tramp
  :defer 10
  :config
  ;; Prevents tramp from asking the remote what the temp directory is
  (put 'temporary-file-directory 'standard-value '("/tmp")))
   #+end_src

** PDF-Tools
   [[https://github.com/politza/pdf-tools][Alternative to DocView for PDF files]]. Requires initial setup though.
   #+begin_src emacs-lisp :tangle yes
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :init
  (when (condition-case nil
            (progn (pdf-info-check-epdfinfo) t)
          (error nil))
    (add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdf-view-mode)))
  :config
  (pdf-tools-install :no-query nil t))
   #+end_src
** Undo Tree
   [[https://www.emacswiki.org/emacs/UndoTree][Undo Tree]] tries to improve on emacs undo system by helping you
   visualize actions.
   #+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :bind
  ("C-x u" . undo-tree-visualize)
  :config
  (setq undo-tree-mode-lighter ""
        undo-tree-visualizer-diff t
        undo-tree-visualizer-timestamps t)
  (global-undo-tree-mode 1))
   #+end_src

** Display Battery & Clock modes
   [[https://www.emacswiki.org/emacs/DisplayBatteryMode][Display Battery Mode]] can show the status of the system
   battery right on the mode line.
   #+begin_src emacs-lisp :tangle yes
(when (functionp 'display-battery-mode)
  (display-battery-mode 1))
   #+end_src
   Along the same lines, I like to be able to check the time from within a
   full-screen frame.
   #+begin_src emacs-lisp :tangle yes
(when (functionp 'display-time-mode)
  (setq display-time-format " h:%H:%M"
        display-time-day-and-date nil
        display-time-default-load-average nil
        display-time-interval 60
        display-time-mail-string "")
  (display-time-mode 1))
   #+end_src
** Zoom-frm
   The [[https://www.emacswiki.org/emacs/zoom-frm.el][zoom-frm]] packages from the [[https://www.emacswiki.org/][EmacsWiki]] provides a way to increase
   font size evenly across the frame.
   #+begin_src emacs-lisp :tangle yes
;; Bootstramp zoom-frm if it is not yet installed
(unless (package-installed-p 'zoom-frm)
  (package-install-file (expand-file-name "site-lisp/frame-fns.el" user-emacs-directory))
  (package-install-file (expand-file-name "site-lisp/frame-cmds.el" user-emacs-directory))
  (package-install-file (expand-file-name "site-lisp/zoom-frm.el" user-emacs-directory)))

(use-package zoom-frm
  :if (and (display-graphic-p)
           (package-installed-p 'zoom-frm))
  :bind ("C-M-=" . zoom-in/out))
   #+end_src
** Epub - Nov
   [[https://github.com/wasamasa/nov.el][Nov]] mode provides a major mode for reading [[https://en.wikipedia.org/wiki/EPUB][EPUB]] documents.
   #+begin_src emacs-lisp :tangle yes
(use-package nov
  :mode ("\\.epub\\'" . nov-mode))
   #+end_src
** w3m
   [[http://w3m.sourceforge.net/][W3m]] is a text-based browser whose engine is used by emacs to serve
   HTML pages. [[http://emacs-w3m.namazu.org][Ensure you have w3m installed]].
   We also add a couple of bindings to open urls externally through
   Firefox.
   #+begin_src emacs-lisp :tangle yes
(use-package w3m
  :bind ("C-x w" . w3m)
  :config
  (setq browse-url-browser-function 'w3m-goto-url-new-session)
  (setq w3m-home-page "https://duckduckgo.com/lite/")
  (defun jr/w3m-open-link-at-point-in-firefox ()
    "Open the w3m anchor at point in Firefox."
    (interactive)
    (browse-url-firefox (w3m-anchor)))
  (defun jr/w3m-open-current-url-in-firefox ()
    "Open the `w3m-current-url' in Firefox"
    (interactive)
    (browse-url-firefox w3m-current-url))
  (define-key w3m-mode-map "X" 'jr/w3m-open-link-at-point-in-firefox)
  (define-key w3m-mode-map "x" 'jr/w3m-open-current-url-in-firefox))
   #+end_src
** Synosaurus
   When writing papers or long emails, it's convenient to have a
   thesaurus right in emacs. The package [[https://github.com/hpdeifel/synosaurus][synosaurus]] wraps around the
   wordnet executable to provide just that functionality.

   Here, we first check if the wordnet executable, wn, is found in the
   PATH and then proceed to download and configure synosaurus.

   One item to note is that sunosaurus defaults to using "C-c C-s" for its
   commands, which is inconvenient in Org mode since "C-c C-s" is Org's
   default binding for org-schedule. Before we load the package, we set
   the prefix to "C-c s" instead.

   #+begin_src emacs-lisp :tangle yes
(use-package synosaurus
  :if (executable-find "wn")
  :delight
  :hook (text-mode . synosaurus-mode)
  :init
  (setq synosaurus-prefix (kbd "C-c s"))
  :config
  (setq synosaurus-backend 'synosaurus-backend-wordnet
        synosaurus-choose-method 'default))
   #+end_src
** Treemacs
   The [[https://github.com/Alexander-Miller/treemacs][treemacs]] package provides a file system tree similar to NerdTree
   for Vim.
   #+begin_src emacs-lisp :tangle yes
(use-package treemacs
  :bind
  (:map global-map
        ("M-0" . treemacs-select-window)
        ("<f8> <f8>" . treemacs))
  :config
  (treemacs-follow-mode t)
  (treemacs-filewatch-mode t)
  (treemacs-fringe-indicator-mode t))

(use-package treemacs-projectile
  :after treemacs projectile)

(use-package treemacs-icons-dired
  :after treemacs dired
  :config (treemacs-icons-dired-mode))

(use-package treemacs-magit
  :after treemacs magit)
   #+end_src
** ace-window
   The [[https://github.com/abo-abo/ace-window][ace-window]] by [[ace-window][abo-abo]] offers an improved way of navigating through
   multiple windows. As part of its configuration, let's have it use the
   keys from the home row instead of the numbers 1-9.
   #+begin_src emacs-lisp :tangle yes
(use-package ace-window
  :bind ("M-o" . 'ace-window)
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
        aw-background nil))
   #+end_src
** erc
   #+begin_src emacs-lisp :tangle yes
(use-package erc
  :delight erc-mode "ε"
  :preface
  (defun jr/connect-to-irc ()
    (interactive)
    (erc :server "irc.libera.chat"
         :port 6667
         :nick "jeko"
         :full-name "Johnny Ruiz (jruiz, jeko, jeko2000)"))
  :bind ("C-c e f" . 'jr/connect-to-irc)
  :config
  (define-key erc-mode-map (kbd "RET") nil)
  (define-key erc-mode-map (kbd "C-c RET") 'erc-send-current-line)
  (define-key erc-mode-map (kbd "C-c C-RET") 'erc-send-current-line)
  (add-to-list 'erc-modules 'autoaway)
  (add-to-list 'erc-modules 'log)
  (add-to-list 'erc-modules 'notifications)
  (add-to-list 'erc-modules 'spelling)
  (erc-update-modules)

  (setq erc-nick-uniquifier "_"
        erc-send-whitespace-lines nil
        erc-rename-buffers t
        erc-interpret-mirc-color t
        erc-save-buffer-on-part t
        erc-query-display 'buffer
        erc-prompt-for-password nil
        erc-kill-server-buffer-on-quit t
        erc-hide-list '("JOIN" "PART" "QUIT")
        erc-lurker-hide-list '("JOIN" "PART" "QUIT")
        erc-timestamp-only-if-changed-flag nil)

  (setq erc-autoaway-idle-seconds 1800
        erc-autoaway-idle-method 'user
        erc-autojoin-delay 2
        erc-autojoin-timing 'ident
        erc-autojoin-channels-alist
        '(("libera.chat"
           "#emacs"
           "#emacs-beginners"
           "#vertx"
           ;; lisp
           "#commonlisp"
           "#lisp"
           "#lisp-es"
           "#lispcafe"
           "#lispweb"))
        erc-keywords '("fix" "resolve" "release" "jruiz" "jeko")
        erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                  "324" "329" "332" "333" "353" "477"))
  ;; logging
  (setq erc-log-channels-directory "~/.erc/logs/")
  (unless (file-exists-p erc-log-channels-directory)
    (mkdir erc-log-channels-directory t)))
   #+end_src
** emacs-server
   #+begin_src emacs-lisp :tangle yes
(use-package server
  :no-require
  :config
  :hook (after-init . server-start))
   #+end_src
** appt
   #+begin_src emacs-lisp :tangle yes
(use-package appt
  :ensure nil
  :config
  (appt-activate 1)
  (setq appt-audible t
        appt-display-duration 15
        appt-display-format 'window
        appt-display-mode-line t
        appt-message-warning-time 12))
   #+end_src
** po-edit
   #+begin_src emacs-lisp :tangle yes
(use-package po-mode
  :mode ("\\.pot?\\'" . po-mode))
   #+end_src
** ag
   The [[https://github.com/ggreer/the_silver_searcher][silver searcher]] is an incredibly useful code-searching tool.
   Though it is similar to ack or grep, it is much, much faster. In order
   to use the ag.el package, make sure to install the binary for your
   operating system.
   #+begin_src emacs-lisp :tangle yes
(use-package ag
  :if (executable-find "ag")
  :defer 10
  :config
  (setq ag-highlight-search t
        ag-reuse-buffers t)
  (use-package wgrep-ag))
   #+end_src
** wgrep
   #+begin_src emacs-lisp :tangle yes
(use-package wgrep
  :defer 10
  :config
  ;;This fixes an issue as discussed on
  ;;https://groups.google.com/forum/#!topic/gnu.emacs.help/uu6ZQZGQ9FA/discussion
  (setq grep-command "grep --color -nH -e "))
   #+end_src
** alert
   #+begin_src emacs-lisp :tangle yes
(use-package alert
  :defer t
  :config
  (setq alert-fade-time 4
        alert-default-style (if (executable-find "notify-send") 'libnotify 'message)
        alert-log-messages t))
   #+end_src

** pinentry
   The [[https://elpa.gnu.org/packages/pinentry.html][pinentry]] package allows GnuPG passphrase to be prompted through
   the minibuffer, which is convenient in tty mode or while connecting
   through ssh.
   #+begin_src emacs-lisp :tangle yes
(use-package pinentry
  :hook (after-init . pinentry-start))
   #+end_src
** smart-mode-line
   #+begin_src emacs-lisp :tangle yes
(use-package smart-mode-line
  :config
  (setq sml/no-confirm-load-theme t)
  (sml/setup)
  (setq sml/theme 'respectful
        sml/shorten-directory t
        sml/shorten-modes t
        sml/name-width 40
        sml/mode-width 'full))
   #+end_src
** eval-sexp-fu
   #+begin_src emacs-lisp :tangle yes
(when (require 'eval-sexp-fu nil :no-error)
  (setq lisp-mode-hook nil)
  (add-hook 'lisp-mode-hook 'turn-on-eval-sexp-fu-flash-mode)
  (add-hook 'elpy-mode-hook 'turn-on-eval-sexp-fu-flash-mode))
   #+end_src
** CSV
   #+begin_src emacs-lisp :tangle yes
(use-package csv-mode
  :mode "\\.csv\\'")
   #+end_src
** Savehist
   [[https://www.emacswiki.org/emacs/SaveHist][Savehist]] is the quick and dirty way to handle session management in
   emacs.
   #+begin_src emacs-lisp :tangle yes
(use-package savehist
  :custom
  (history-delete-duplicates t)
  (history-length t)
  (savehist-additional-variables
   '(kill-ring
     search-ring
     regexp-search-ring))
  (savehist-file (expand-file-name "history" user-emacs-directory))
  (savehist-save-minibuffer-history 1)
  :config (savehist-mode 1))
   #+end_src
** Auto-revert
   Quick configuration for auto reverting files.
   #+begin_src emacs-lisp :tangle yes
(use-package autorevert
  :delight
  :bind ("C-x R" . revert-buffer)
  :config
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t
	auto-revert-verbose t))
   #+end_src
** Which-key
   Useful package that displays possible keybindings from the currently
   entered incomplete command.
   #+begin_src emacs-lisp :tangle yes
(use-package which-key
  :defer 10
  :delight
  :commands which-key-mode
  :config
  (which-key-mode)
  (setq which-key-idle-delay 1
        which-key-max-description-length 30))
   #+end_src
** Ledger
   Yet another awesome piece of work from John Wiegley
   (http://www.newartisans.com/). [[http://git.ledger-cli.org/][Ledger]] is the double-entry accounting
   system to rule them all.
   #+begin_src emacs-lisp :tangle yes
(use-package ledger-mode
  :mode "\\.ledger\\'"
  :config
  (setq ledger-clear-whole-transactions t
        ledger-reconcile-default-commodity "USD"
        ledger-reconcile-default-date-format "%Y/%m/%d")
  (use-package flycheck-ledger
    :init
    (add-hook 'ledger-mode-hook #'flycheck-mode)))
   #+end_src
** Super Save
   [[https://github.com/bbatsov/super-save/][Super Save]] replaces the standard auto-save-mode.
   #+begin_src emacs-lisp :tangle yes
(use-package super-save
  :delight
  :config
  (super-save-mode 1)
  (setq super-save-auto-save-when-idle t
        super-save-remote-files nil))
   #+end_src
** EasyPG
   #+begin_src emacs-lisp :tangle yes
(require 'epg-config)
(add-to-list 'epg-config--program-alist
             `(OpenPGP epg-gpg-program
                       ("gpg" . ,epg-gpg-minimum-version)))
(setq epa-file-cache-passphrase-for-symmetric-encryption t
      epg--configurations nil)
   #+end_src
** Hydra
#+begin_src emacs-lisp :tangle yes
(use-package hydra
  :defer t
  :config
  (defhydra hydra-zoom (global-map "<f2>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out"))
  (defhydra hydra-buffer-menu (:color pink
                                      :hint nil)
    "
^Mark^             ^Unmark^           ^Actions^          ^Search
^^^^^^^^-----------------------------------------------------------------
_m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
_s_: save          _U_: unmark up     _b_: bury          _I_: isearch
_d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
_D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
_~_: modified
"
    ("m" Buffer-menu-mark)
    ("u" Buffer-menu-unmark)
    ("U" Buffer-menu-backup-unmark)
    ("d" Buffer-menu-delete)
    ("D" Buffer-menu-delete-backwards)
    ("s" Buffer-menu-save)
    ("~" Buffer-menu-not-modified)
    ("x" Buffer-menu-execute)
    ("b" Buffer-menu-bury)
    ("g" revert-buffer)
    ("T" Buffer-menu-toggle-files-only)
    ("O" Buffer-menu-multi-occur :color blue)
    ("I" Buffer-menu-isearch-buffers :color blue)
    ("R" Buffer-menu-isearch-buffers-regexp :color blue)
    ("c" nil "cancel")
    ("v" Buffer-menu-select "select" :color blue)
    ("o" Buffer-menu-other-window "other-window" :color blue)
    ("q" quit-window "quit" :color blue))
  (define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body))

#+end_src
** PlantUML
Emacs integration with [[https://plantuml.com/][PlantUML]].
#+begin_src emacs-lisp :tangle yes
  (use-package plantuml-mode
    :mode "\\.plantuml\\'"
    :config
    ;; Set execution mode to executable, if possible
    (cond ((executable-find "plantuml")
           (setq plantuml-default-exec-mode 'executable
                 plantuml-executable-path "plantuml"))
          (t
           (setq plantuml-default-exec-mode 'server)
           (warn "Install plantuml executable")))
    (setq plantuml-indent-level 4)
    ;; register with org mode
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml)))

  (use-package flycheck-plantuml
    :after flycheck plantuml
    :hook (plantuml-mode . flyspell-mode))
#+end_src
** doom modeline
#+begin_src emacs-lisp :tangle yes
(use-package doom-modeline)
#+end_src
* Programming packages
** Generic
*** Display line numbers mode
#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src
*** Company
    [[http://company-mode.github.io/][Complete anything]] in emacs with company-mode.
    #+begin_src emacs-lisp :tangle yes
(use-package company
  :defer 2
  :bind (("TAB" . company-complete)
         (:map company-active-map
               ("C-n" . company-select-next)
               ("C-p" . company-select-previous)))
  :config
  (global-company-mode t)
  (setq company-idle-delay .3
        company-minimum-prefix-length 2
        company-show-numbers t
        company-tooltip-align-annotations t))

(use-package company-dabbrev
  :ensure nil
  :config
  (setq company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil
        company-dabbrev-minimum-length 3))

(use-package company-dabbrev-code
  :ensure nil
  :config
  (setq company-dabbrev-code-everywhere t
        company-dabbrev-code-ignore-case nil))

(use-package company-box
  ;; https://github.com/sebastiencs/company-box
  ;; Per docs, this package requires emacs 26
  :if (>= emacs-major-version 26)
  :after company
  :hook (company-mode . company-box-mode)
  :config
  (setq company-box-enable-icon t
        company-box-doc-enable t
        company-box-doc-delay 0.3))

(use-package company-statistics
  :after company
  :hook (company-mode . company-statistics-mode))

(use-package company-restclient
  :after company restclient)
    #+end_src
*** Misc
    #+begin_src emacs-lisp :tangle yes
;; See https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/
(defun jr/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(define-key prog-mode-map (kbd "C-a") #'jr/smarter-move-beginning-of-line)
    #+end_src
*** Flyspell
    [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html][Flyspell]] brings automatic spell-checking to emacs buffers.
    #+begin_src emacs-lisp :tangle yes
(use-package flyspell
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode))
  :config
  (cond
   ((executable-find "hunspell")
    (setq ispell-program-name "hunspell"))
   ((executable-find "aspell")
    (setq ispell-program-name "aspell")))
  (setq ispell-local-dictionary "en_US"))
    #+end_src
*** Ediff
    [[https://www.gnu.org/software/emacs/manual/html_node/ediff/][Ediff]] allows simultaneous browsing through the differences between
    files or buffers. Very handy for comparing commits.
    #+begin_src emacs-lisp :tangle yes
(use-package ediff
  :config
  (setq ediff-diff-options "-w"
        ediff-split-window-function 'split-window-horizontally
        ediff-window-setup-function 'ediff-setup-windows-plain))
    #+end_src
*** Sexp highlighting
    [[https://www.emacswiki.org/emacs/ShowParenMode][show-paren-mode]] allows to see matching pairs of parentheses and other characters.
    #+begin_src emacs-lisp :tangle yes
(show-paren-mode 1)
(setq show-paren-style 'parenthesis
      show-paren-delay 0)
    #+end_src
*** Indentation
    I like to automatically indent when press RET
    #+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "RET") 'newline-and-indent)
(use-package aggressive-indent
  :defer 2
  :hook ((css-mode        . aggressive-indent-mode)
         (emacs-lisp-mode . aggressive-indent-mode)
         (lisp-mode       . aggressive-indent-mode)))
    #+end_src
*** Code Folding
    The [[https://www.emacswiki.org/emacs/HideShow][hideshow]] minor mode allows one to hide and show blocks of text.
    #+begin_src emacs-lisp :tangle yes
(use-package hideshow
  :ensure nil
  :delight
  :config
  (progn
    ;; Hide the comments too when you do a 'hs-hide-all'
    (setq hs-hide-comments t)
    ;; Set whether isearch opens folded comments, code, or both
    ;; where x is code, comments, t (both), or nil (neither)
    (setq hs-isearch-open 't)))
    #+end_src
*** Snippets
    The all great [[https://github.com/joaotavora/yasnippet][yasnippet]] package provides an extensible template system
    for Emacs. To get the actual snippets, we can use the great collection
    maintained by [[https://github.com/AndreaCrotti][AndreaCrotti]] named yasnippet-snippets.
    We also download [[https://github.com/mkcms/ivy-yasnippet][ivy-yasnippet]] by [[https://github.com/mkcms][mkcms]] to allow snippet previews through [[https://github.com/abo-abo/swiper][ivy]].
    #+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :delight yas-minor-mode
  :bind (("C-c y TAB" . yas-expand)
         ("C-c y s"   . yas-insert-snippet)
         ("C-c y n"   . yas-new-snippet)
         ("C-c y v"   . yas-visit-snippet-file))
  :config
  (yas-global-mode 1))

(use-package yasnippet-snippets
  :after yasnippet)

(use-package ivy-yasnippet
  :after yasnippet
  :bind ("C-c y y" . ivy-yasnippet))

    #+end_src

*** Completion
**** Ivy
     [[https://github.com/abo-abo/swiper][Ivy]] provides a completion mechanism for Emacs.
     It is my preferred completion method at the moment for its simplicity.
     Bundled, we find swiper and counsel which extend ivy.
     #+begin_src emacs-lisp :tangle yes
(use-package ivy
  :delight
  :demand t
  :bind (("C-x b" . ivy-switch-buffer)
         ("C-x B" . ivy-switch-buffer-other-window))
  :bind (:map ivy-switch-buffer-map
              ("C-k" . ivy-switch-buffer-kill))
  :custom
  (ivy-dynamic-exhibit-delay-ms 200)
  (ivy-height 10)
  (ivy-initial-inputs-alist nil t)
  (ivy-magic-tilde nil)
  (ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
  (ivy-use-virtual-buffers t)
  (ivy-wrap t)
  :config
  (ivy-mode 1)
  (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))

(use-package ivy-rich
  :after ivy
  :config
  (ivy-rich-mode)
  (setq ivy-virtual-abbreviate 'full
        ivy-rich-switch-buffer-align-virtual-buffer t
        ivy-rich-path-style 'abbrev))

(use-package swiper
  :after ivy)

(use-package counsel
  :after ivy
  :delight
  :init
  (setq counsel-grep-swiper-limit 3000000)
  :bind (("C-h f"   . counsel-describe-function)
         ("C-*"     . counsel-org-agenda-headlines)
         ("<f1> f"  . counsel-describe-function)
         ("<f1> v"  . counsel-describe-variable)
         ("<f1> l"  . counsel-find-library)
         ("<f2> i"  . counsel-info-lookup-symbol)
         ("<f2> u"  . counsel-unicode-char)
         ("<f2> j"  . counsel-set-variable)
         ("C-x C-f" . counsel-find-file)
         ("C-x C-r" . counsel-recentf)
         ("M-x"     . counsel-M-x)
         ("M-y"     . counsel-yank-pop)
         ("C-s"     . counsel-grep-or-swiper)))
     #+end_src
*** Version Control
    Version control is of incredibly importance for most projects and
    [[https://magit.vc][magit]] provides a great interface for [[https://git-scm.com/][git]]. [[https://github.com/magit/orgit][Orgit]] provides new [[https://orgmode.org/manual/External-links.html][org-link]]
    types for Magit buffers.

    #+begin_src emacs-lisp :tangle yes
(use-package magit
  :bind ("C-c g" . magit-status)
  :hook ((magit-mode . hl-line-mode)
         (magit-log-mode . hl-line-mode))
  :config
  (use-package git-gutter
    :delight
    :config
    (global-git-gutter-mode +1))
  (use-package git-timemachine))
    #+end_src
*** REST support
    See [[http://emacsrocks.com/e15.html][Emacs Rocks! Episode 15]] to learn how [[https://github.com/pashky/restclient.el][restclient]] can help out with
    testing APIs from within Emacs. The HTTP calls you make in the buffer
    aren't constrainted within Emacs; there’s the
    restclient-copy-curl-command to get the equivalent curl call string to
    keep things portable.
    #+begin_src emacs-lisp :tangle yes
(use-package restclient
  :mode ("\\.rest\\'" . restclient-mode))
    #+end_src
*** Multiple cursors
    See [[http://emacsrocks.com/e13.html][Emacs Rocks! Episode 13]] to learn about [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]], written
    by [[https://github.com/magnars/.emacs.d][Magnars Sveen]].
    #+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C-+"         . mc/mark-next-like-this)
         ("C-_"         . mc/mark-previous-like-this)
         ("C-c C-+"     . mc/mark-all-like-this)
         ("C-!"         . mc/mark-next-symbol-like-this)
         ("s-d"         . mc/mark-all-dwim)))
    #+end_src
*** Expand Region
    See [[http://emacsrocks.com/e09.html][Emacs Rocks! Episode 9]] to learn about [[https://github.com/magnars/.emacs.d][Magnars Sveen]]'s excellent
    expand-region.
    #+begin_src emacs-lisp :tangle yes
(use-package expand-region
  :defer 2
  :bind ("C-=" . er/expand-region))
    #+end_src
*** Autofill mode
    I find myself using M-q often to [[https://www.emacswiki.org/emacs/FillParagraph][refill paragraphs]]. [[https://www.emacswiki.org/emacs/AutoFillMode][AutoFillMode]] mostly
    automates this for me.
    #+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(global-set-key (kbd "C-c q") 'auto-fill-mode)
(setq comment-auto-fill-only-comments t)
    #+end_src
*** Whitespace-cleanup-mode
    [[https://github.com/purcell/whitespace-cleanup-mode][whitespace-cleanup-mode]] is a better solution than just having
    the whitespace-cleanup function running as part of the before-save-hook.
    #+begin_src emacs-lisp :tangle yes
(use-package whitespace-cleanup-mode
  :delight
  :config
  (global-whitespace-cleanup-mode 1))
    #+end_src
*** Smartparens
    #+begin_src emacs-lisp :tangle yes
(use-package smartparens
  :diminish t
  :init
  :config
  (progn
    (require 'smartparens-config)
    (sp-pair "(" ")" :wrap "s-(")
    (sp-pair "[" "]" :wrap "s-[")
    (sp-pair "{" "}" :wrap "s-{")
    (sp-with-modes
        '(java-mode json-mode typescript-mode js-mode)
      (sp-local-pair "{" nil :post-handlers '(:add ("||\n[i]" "RET")))
      (sp-local-pair "[" nil :post-handlers '(:add ("||\n[i]" "RET")))
      (sp-local-pair "(" nil :post-handlers '(:add ("||\n[i]" "RET"))))
    (add-hook 'smartparens-mode-hook #'show-smartparens-mode)
    (add-hook 'prog-mode-hook #'turn-on-smartparens-strict-mode)
    ;; The following is necessary per https://github.com/Fuco1/smartparens/issues/963
    ;; (add-to-list 'sp--special-self-insert-commands 'c-electric-paren)
    ;; (add-to-list 'sp--special-self-insert-commands 'c-electric-brace)
    (bind-keys
     :map smartparens-mode-map
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)

     ("C-<down>" . sp-down-sexp)
     ("C-<up>"   . sp-up-sexp)
     ("M-<down>" . sp-backward-down-sexp)
     ("M-<up>"   . sp-backward-up-sexp)

     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)

     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)

     ("C-S-f" . sp-forward-symbol)
     ("C-S-b" . sp-backward-symbol)

     ("C-<right>" . sp-forward-slurp-sexp)
     ("M-<right>" . sp-forward-barf-sexp)
     ("C-<left>"  . sp-backward-slurp-sexp)
     ("M-<left>"  . sp-backward-barf-sexp)

     ("C-M-t" . sp-transpose-sexp)
     ("C-M-k" . sp-kill-sexp)
     ("C-k"   . sp-kill-hybrid-sexp)
     ("M-k"   . sp-backward-kill-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("C-M-d" . delete-sexp)

     ("M-<backspace>" . backward-kill-word)
     ("C-<backspace>" . sp-backward-kill-word)
     ([remap sp-backward-kill-word] . backward-kill-word)

     ("M-[" . sp-backward-unwrap-sexp)
     ("M-]" . sp-unwrap-sexp)

     ("C-x C-t" . sp-transpose-hybrid-sexp))))
    #+end_src
*** projectile-mode
    The useful [[https://github.com/bbatsov/projectile][projectile-mode]] package by [[https://github.com/bbatsov/][bbastov]] provides lots of tools
    to interact with your project, which is defined as a simple folder
    with a special file such as .project, .projectile and many other
    supported types.
    #+begin_src emacs-lisp :tangle yes
(use-package projectile
  :delight '(:eval (concat " " (projectile-project-name)))
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init   (setq projectile-use-git-grep t)
  :config
  (setq projectile-completion-system 'ivy
        projectile-enable-caching t
        projectile-sort-order 'recentf
        projectile-track-known-projects-automatically t))

(use-package counsel-projectile
  :after counsel projectile
  :config
  (counsel-projectile-mode 1))
    #+end_src
*** Flycheck
    Per the [[http://www.flycheck.org/en/latest/][flycheck website]], Flycheck is a modern on-the-fly syntax
    checking extension for GNU Emacs, intended as replacement for the
    older Flymake extension which is part of GNU Emacs.
    #+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :config
  (setq flycheck-check-syntax-automatically '(save idle-change new-line mode-enabled)))

(use-package flycheck-color-mode-line
  :after flycheck
  :commands flycheck-color-mode-line-mode
  :hook (flycheck-mode . flycheck-color-mode-line-mode))
    #+end_src
*** GGTags
    #+begin_src emacs-lisp :tangle no
;; GNU Global Tags
(use-package ggtags
  :commands ggtags-mode
  :diminish ggtags-mode
  :bind (("M-," . pop-tag-mark)
         ("M-." . ggtags-find-tag-dwim)
         ("C-c t s" . ggtags-find-other-symbol)
         ("C-c t h" . ggtags-view-tag-history)
         ("C-c t r" . ggtags-find-reference)
         ("C-c t f" . ggtags-find-file)
         ("C-c t c" . ggtags-create-tags))
  :init
  (add-hook 'c-mode-common-hook
            #'(lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                  (ggtags-mode 1))))
  :config
  (progn
    (add-hook 'c-mode-common-hook
              (lambda ()
                (ggtags-mode 1)
                (add-to-list 'c-default-style '(c++ . "stroustrup"))
                (smartparens-strict-mode 1)
                (define-key c++-mode-map (kbd "<f5>") (lambda ()
                                                        (interactive)
                                                        (setq-local compilation-read-command nil)
                                                        (call-interactively 'compile)))
                (sp-with-modes '(c-mode c++-mode java-mode)
                  (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
                  ;; (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                  ;;                                           ("* ||\n[i]" "RET")))
                  )))))
    #+end_src

*** LSP
    #+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :init
  (setq lsp-keymap-prefix "C-c C-l")
  (defun jr/lsp-breadcrum-setup ()
    (setq lsp-headerline-breadcrumb-segments '(project path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))
  
  :hook ((lsp-mode . lsp-enable-which-key-integration)
         (lsp-mode . jr/lsp-breadcrum-setup))
  :bind (:map lsp-mode-map
              ("C-<return>" . lsp-execute-code-action))
  :config
  ;; Performance tuning
  (setq read-process-output-max (* 1024 1024)
        gc-cons-threshold (* 100 1024 1024)
        lsp-completion-provider :capf
        lsp-idle-delay 0.500
        lsp-log-io nil)
  (setq-local company-minimum-prefix-length 1
              company-idle-delay 0.0))

(use-package lsp-ui
  :after lsp-mode
  :config
  (setq lsp-ui-sideline-enable nil
        lsp-ui-peek-enable nil
        lsp-ui-doc-position 'bottom
        lsp-ui-doc-enable t
        lsp-ui-doc-delay 1.0))

(use-package lsp-treemacs
  :after lsp-mode
  :hook (lsp-mode . lsp-treemacs-sync-mode)
  :config
  (setq lsp-treemacs-error-list-severity 3))

(use-package lsp-ivy
  :after ivy lsp-mode
  :commands lsp-ivy-workspace-symbol)

(use-package dap-mode
  :after lsp-mode
  :config
  (dap-mode t)
  (dap-ui-mode t)
  (dap-auto-configure-mode))
    #+end_src

** Language Specific
*** Eshell
    [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]] is a shell-like command interpreter implemented in Emacs Lisp and written
    by the great [[https://www.google.com/search?q=eshell+jwiegleyt&ie=utf-8&oe=utf-8][John Wiegley]].
    #+begin_src emacs-lisp :tangle yes
(use-package eshell
  :bind ("C-x t" . eshell)
  :preface
  (defun jr/eshell-mode-hook ()
    (display-line-numbers-mode -1))
  :config
  (progn
    (defalias 'open 'find-file)
    (defalias 'openo 'find-file-other-window)
    (add-hook 'eshell-mode-hook #'jr/eshell-mode-hook)))
    #+end_src

*** Clojure
    [[https://www.google.com/search?q=clojure&ie=utf-8&oe=utf-8][Clojure]] is a dynamic programming language that compiles to Java
    Unicode. It's one of my main languages right now.
    #+begin_src emacs-lisp :tangle yes
(use-package clojure-mode
  :init
  (defun jr/clojure-mode-hook ()
    (aggressive-indent-mode)
    (smartparens-strict-mode)
    (yas-minor-mode)
    (company-mode)
    (eldoc-mode))
  :hook ((clojure-mode . jr/clojure-mode-hook))
  :config
  (setq clojure-indent-style 'align-arguments
        clojure-align-forms-automatically t))

(use-package cider  
  :hook ((clojure-mode . cider-mode))
  :config
  (define-key cider-mode-map (kbd "C-c C-j i") #'cider-completion-flush-caches)
  (setq cider-use-overlays 'both
        cider-prompt-for-symbol nil
        cider-prefer-local-resources t
        cider-eldoc-display-context-dependent-info t
        cider-overlays-use-font-lock t
        cider-result-overlay-position 'at-point))

(use-package clj-refactor
  :after clojure-mode
  :hook ((clojure-mode . clj-refactor-mode))
  :config
  (cljr-add-keybindings-with-prefix "C-c C-m"))

(use-package cider-hydra
  :after cider hydra
  :hook ((clojure-mode . cider-hydra-mode)))

    #+end_src
*** Common Lisp
    [[https://common-lisp.net/][Common Lisp]], the programmable programming language.
    The following sets up [[https://www.emacswiki.org/emacs/SlimeMode][slime]] to use [[http://www.sbcl.org/][SBCL]] so ensure you have SBCL
    installed first:
    #+begin_src emacs-lisp :tangle yes
(use-package slime-company
  :defer t)

(use-package slime
  :bind (("C-c C-d C-s" . slime-describe-symbol)
         ("C-c C-d C-f" . slime-describe-function))
  :init
  (setq slime-lisp-implementations '((sbcl ("sbcl")))
        slime-default-lisp 'sbcl)
  (let ((hyperspec-root "/opt/homebrew/share/doc/hyperspec/HyperSpec/"))
    (when (file-exists-p hyperspec-root)
      (setq common-lisp-hyperspec-root hyperspec-root)
      (setq common-lisp-hyperspec-symbol-table
            (concat common-lisp-hyperspec-root "Data/Map_Sym.txt"))
      (setq common-lisp-hyperspec-issuex-table
            (concat common-lisp-hyperspec-root "Data/Map_IssX.txt"))))
  (slime-setup '(slime-fancy slime-company slime-cl-indent))
  (when (file-exists-p "~/quicklisp/slime-helper.el")
    (load (expand-file-name "~/quicklisp/slime-helper.el"))))

(use-package common-lisp-snippets
  :defer t)

;; Source https://dnaeon.github.io/starting-with-common-lisp-in-2020/
(defun slime-description-fontify ()
  (with-current-buffer "*slime-description*"
    (slime-company-doc-mode)))

(defadvice slime-show-description (after slime-description-fontify activate)
  "Fontify sections of SLIME Description."
  (slime-description-fontify))
    #+end_src
*** Scheme
    [[https://en.wikipedia.org/wiki/Scheme_%2528programming_language%2529][Scheme]] is a dialect of Lisp developed by Gerald Sussman and Guy
    Steele.
    [[https://github.com/jaor/geiser][Geiser]] provides an improved development environment in emacs.
    #+begin_src emacs-lisp :tangle yes
(use-package geiser
  :defer t
  :config
  (progn
    (setq geiser-active-implementations '(mit)
          geiser-mit-binary "/usr/bin/mit-scheme")
    (setq scheme-program-name "/usr/bin/mit-scheme")))
    #+end_src
*** Emacs Lisp
    #+begin_src emacs-lisp :tangle yes
(defun eval-and-replace ()
  "Replace the preceding sexp with its value.
    Source: http://emacsredux.com/blog/2013/06/21/eval-and-replace/"
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun jr/noisy-eval-buffer ()
  "Evaluate the current buffer and print a simple message"
  (interactive)
  (eval-buffer)
  (message "Visible section in buffer %s has been evaluated." (buffer-name)))

(define-key lisp-mode-map (kbd "C-c e b") 'jr/noisy-eval-buffer)
(define-key lisp-mode-map (kbd "C-c e d") 'toggle-debug-on-error)
(define-key lisp-mode-map (kbd "C-c e c") 'emacs-lisp-byte-compile-and-load)
(define-key lisp-mode-map (kbd "C-c e r") 'eval-region)
(define-key lisp-mode-map (kbd "C-c e e") 'eval-and-replace)

(define-key emacs-lisp-mode-map (kbd "C-c C-m") #'pp-macroexpand-last-sexp)

(define-key lisp-interaction-mode-map (kbd "C-c e b") 'jr/noisy-eval-buffer)
(define-key lisp-interaction-mode-map (kbd "C-c e d") 'toggle-debug-on-error)
(define-key lisp-interaction-mode-map (kbd "C-c e c") 'emacs-lisp-byte-compile-and-load)
(define-key lisp-interaction-mode-map (kbd "C-c e r") 'eval-region)
(define-key lisp-interaction-mode-map (kbd "C-c e e") 'eval-and-replace)

;; Let's add a couple of bindings to C-c C-z to be able to switch back
;; and forth between an emacs-lisp buffer and ielm
(defcustom jr/ielm-repl-display-in-current-window nil
  "When non-nil, show the ielm REPL buffer in the current window."
  :type 'boolean
  :group 'ielm)

(defun jr/ielm-switch-to-ielm-buffer ()
  "Switch to the ielm buffer in an existing window, when
  possible. If `jr/ielm-repl-display-in-current-window' is non-nil,
  then attempt to use the same window."
  (interactive)
  (let ((ielm-buff-name "*ielm*"))
    (unless (comint-check-proc ielm-buff-name)
      (with-current-buffer (get-buffer-create ielm-buff-name)
        (inferior-emacs-lisp-mode)))
    (if jr/ielm-repl-display-in-current-window
        (pop-to-buffer-same-window ielm-buff-name)
      (pop-to-buffer ielm-buff-name))))

(define-key emacs-lisp-mode-map (kbd "C-c C-z") 'jr/ielm-switch-to-ielm-buffer)

(defun jr/ielm-switch-to-last-emacs-lisp-buffer ()
  "Switch to the last emacs-lisp buffer in an existing window,
  when possible. If `jr/ielm-repl-display-in-current-window' is
  non-nil, then attempt to use the same window."
  (interactive)
  (when (eq major-mode 'inferior-emacs-lisp-mode)
    (let ((last-buff (seq-find (lambda (b)
                                 (with-current-buffer b
                                   (eq major-mode 'emacs-lisp-mode)))
                               (buffer-list))))
      (when last-buff
        (if jr/ielm-repl-display-in-current-window
            (pop-to-buffer-same-window last-buff)
          (pop-to-buffer last-buff))))))

(use-package ielm
  :disabled t
  :config
  (progn
    (define-key ielm-map (kbd "C-c C-z") 'jr/ielm-switch-to-last-emacs-lisp-buffer)))

(bind-key "RET" 'comment-indent-new-line emacs-lisp-mode-map)

(use-package eldoc
  :ensure nil
  :diminish eldoc-mode
  :commands eldoc-mode
  :config
  (global-eldoc-mode))

    #+end_src
*** Markdown
    I like to edit README and other files written in Markdown so having
    [[https://jblevins.org/projects/markdown-mode/][markdown-mode]] is very convenient.
    #+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :mode "\\.md\\'")
    #+end_src
*** TeX/LaTeX
    #+begin_src emacs-lisp :tangle yes
(use-package tex
  :ensure auctex
  :mode ("\\.tex\\'" . TeX-latex-mode)
  :config
  (progn
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-byte-compile t
          TeX-master 'dwim
          TeX-view-program-selection '((output-pdf "Evince")
                                       (output-html "xdg-open"))
          TeX-engine 'xetex)
    (TeX-source-correlate-mode 1)
    (use-package company-auctex
      :config (company-auctex-init))))
    #+end_src

*** Web editing
    The [[http://web-mode.org/][web-mode]] is particularily good for editing HTML templates. It
    natively understands embedded CSS and JavaScript code blocks.

    We also install [[https://github.com/emacsmirror/rainbow-mode][rainbow-mode]] to colorize color names in web and CSS buffers.
    #+begin_src emacs-lisp :tangle yes
(use-package web-mode
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2)
  :mode (("\\.html?\\'" . web-mode)
         ("\\.mustache\\'" . web-mode)
         ("\\.xhtml?\\'" . web-mode)
         ("\\.xml\\'" . web-mode)
         ("\\.hbs\\'" . web-mode))
  :config
  (progn
    (use-package rainbow-mode
      :hook (web-mode css-mode)
      :defer t
      :config
      (progn
        (add-hook 'web-mode-hook #'rainbow-mode)
        (add-hook 'css-mode-hook #'rainbow-mode)))
    (use-package company-web
      :config
      (define-key web-mode-map (kbd "C-'") 'company-web-html))))
    #+end_src

    [[https://github.com/skeeto/impatient-mode][Impatient mode]] allows one to see changes to HTML buffers _instantly_
    as you type which is very cool. There's even this [[http://youtu.be/QV6XVyXjBO8][YouTube video]] that
    shows what it does.

    Oh, and remember that [[https://github.com/rg3/youtube-dl][youtube-dl]] is a great way to download/watch
    YouTube videos!
    #+begin_src emacs-lisp :tangle yes
(use-package simple-httpd)
(use-package impatient-mode
  :init (defun jr/impatient-mode ()
          (interactive)
          (unless (httpd-running-p)
            (httpd-start)
            (browse-url "http://localhost:8080/imp/"))
          (impatient-mode +1)
          (message "Impatient mode enabled in the following buffers: %s" (princ (imp--buffer-list))))
  :bind ("C-c i" . jr/impatient-mode)
  :after simple-httpd
  :config
  (setq impatient-mode-delay 0.1))
    #+end_src

    Emmet mode
    #+begin_src emacs-lisp :tangle yes
(use-package emmet-mode
  :init
  (defun duplicate-line (arg)
    "Duplicate current line, leaving point in lower line."
    (interactive "*p")

    ;; save the point for undo
    (setq buffer-undo-list (cons (point) buffer-undo-list))

    ;; local variables for start and end of line
    (let ((bol (save-excursion (beginning-of-line) (point)))
          eol)
      (save-excursion

        ;; don't use forward-line for this, because you would have
        ;; to check whether you are at the end of the buffer
        (end-of-line)
        (setq eol (point))

        ;; store the line and disable the recording of undo information
        (let ((line (buffer-substring bol eol))
              (buffer-undo-list t)
              (count arg))
          ;; insert the line arg times
          (while (> count 0)
            (newline)         ;; because there is no newline in 'line'
            (insert line)
            (setq count (1- count)))
          )

        ;; create the undo information
        (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list)))
      ) ; end-of-let

    ;; put the point in the lowest line and return
    (next-line arg))
  :bind (:map emmet-mode-keymap
              ("<tab>" . emmet-expand-line)
              ("C-t" . duplicate-line))
  :hook
  ((sgml-mode . emmet-mode)
   (web-mode . emmet-mode)
   (css-mode . emmet-mode))
  :config
  (add-hook 'emmet-mode-hook (lambda () (smartparens-strict-mode -1)))
  (setq emmet-move-cursor-between-quotes t))
    #+end_src
    
*** Java
    #+begin_src emacs-lisp :tangle yes
(use-package lsp-java
  :init
  (defun jr/lsp-java-config ()
    (setq-local tab-width 4
                c-basic-offset 4)
    (setq c-default-style "java"
          indent-tags-mode nil
          compile-command "mvn -q compile"))
  :hook ((java-home . jr/lsp-java-config)))

(use-package dap-java
  :ensure nil
  :after (lsp-java)
  :config
  (define-key lsp-mode-map (kbd "C-c C-l d d") #'dap-java-debug-test-class))

(use-package java-snippets
  :after yasnippet
  :config
  (java-snippets-initialize))
    #+end_src
**** Gradle
     #+begin_src emacs-lisp :tangle yes
(use-package gradle-mode
  :delight gradle-mode "γ"
  :mode "\\.gradle\\'"
  :interpreter ("gradle" . gradle-mode)
  :config
  (add-hook 'java-mode-hook '(lambda() (gradle-mode 1))))
     #+end_src
*** Python
#+begin_src emacs-lisp :tangle yes
(use-package python
  :ensure nil)

(use-package lsp-pyright)

(use-package pyvenv
  :config
  (add-hook 'pyvenv-post-activate-hooks 'pyvenv-restart-python))
#+end_src
*** SQL
    #+begin_src emacs-lisp :tangle yes
(use-package sql-mode
  :ensure nil
  :mode ("\\.sql\\'" "\\.pgsql\\'"))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
(use-package sqlformat
  :if (executable-find "pg_format")
  :init
  (defun jr/sqlformat-hook ()
    (setq-local indent-region-function #'sqlformat-region))
  :hook (sql-mode . jr/sqlformat-hook)
  :config
  ;; -a | --anonymize      : obscure all literals in queries, useful to hide
  ;;                         confidential data before formatting.
  ;; -b | --comma-start    : in a parameters list, start with the comma (see -e)
  ;; -B | --comma-break    : in insert statement, add a newline after each comma.
  ;; -c | --config FILE    : use a configuration file. Default is to use local
  ;;                         file .pg_format or ~/.pg_format if they exists.
  ;; -C | --wrap-comment   : with --wrap-limit, apply reformatting to comments.
  ;; -d | --debug          : enable debug mode. Disabled by default.
  ;; -e | --comma-end      : in a parameters list, end with the comma (default)
  ;; -f | --function-case N: Change the case of the reserved keyword. Default is
  ;;                         unchanged: 0. Values: 0=>unchanged, 1=>lowercase,
  ;;                         2=>uppercase, 3=>capitalize.
  ;; -F | --format STR     : output format: text or html. Default: text.
  ;; -g | --nogrouping     : add a newline between statements in transaction
  ;;                         regroupement. Default is to group statements.
  ;; -h | --help           : show this message and exit.
  ;; -i | --inplace        : override input file with formatted content.
  ;; -k | --keep-newline   : preserve empty line in plpgsql code.
  ;; -L | --no-extra-line  : do not add an extra empty line at end of the output.
  ;; -m | --maxlength SIZE : maximum length of a query, it will be cutted above
  ;;                         the given size. Default: no truncate.
  ;; -M | --multiline      : enable multi-line search for -p or --placeholder.
  ;; -n | --nocomment      : remove any comment from SQL code.
  ;; -N | --numbering      : statement numbering as a comment before each query.
  ;; -o | --output file    : define the filename for the output. Default: stdout.
  ;; -p | --placeholder RE : set regex to find code that must not be changed.
  ;; -r | --redshift       : add RedShift keyworks to the list of SQL keyworks.
  ;; -s | --spaces size    : change space indent, default 4 spaces.
  ;; -S | --separator STR  : dynamic code separator, default to single quote.
  ;; -t | --format-type    : try another formatting type for some statements.
  ;; -T | --tabs           : use tabs instead of space characters, when used
  ;;                         spaces is set to 1 whatever is the value set to -s.
  ;; -u | --keyword-case N : Change the case of the reserved keyword. Default is
  ;;                         uppercase: 2. Values: 0=>unchanged, 1=>lowercase,
  ;;                         2=>uppercase, 3=>capitalize.
  ;; -U | --type-case N    : Change the case of the data type name. Default is
  ;;                         lowercase: 1. Values: 0=>unchanged, 1=>lowercase,
  ;;                         2=>uppercase, 3=>capitalize.
  ;; -v | --version        : show pg_format version and exit.
  ;; -w | --wrap-limit N   : wrap queries at a certain length.
  ;; -W | --wrap-after N   : number of column after which lists must be wrapped.
  ;;                         Default: puts every item on its own line.
  ;; -X | --no-rcfile      : do not read ~/.pg_format automatically. The
  ;;                         --config / -c option overrides it.
  ;; --extra-function FILE : file containing a list of function to use the same
  (setq sqlformat-command 'pgformatter
        sqlformat-args '("-C" "-f2" "-g" "-L" "-M" "-s2" "-u2" "-U2" "-t")))
    #+end_src
*** JavaScript
    #+begin_src emacs-lisp :tangle yes
(use-package js
  :init
  (defun jr/js-setup-lsp ()
    (interactive)
    (require 'dap-node)
    (lsp)
    (dap-mode)
    (dap-node-setup))
  :hook
  (js-mode . jr/js-setup-lsp)
  :config
  (let ((indent-level 2))
    (setq js-chain-indent t
          js-indent-level indent-level
          js-jsx-attribute-offset indent-level
          js-jsx-detect-syntax t
          js-jsx-align->-with-< t
          js-jsx-indent-level indent-level)))
    #+end_src
*** Move-text
    #+begin_src emacs-lisp :tangle yes
(use-package move-text
  :disabled t
  :defer 2
  :bind (("M-p" . move-text-up)
         ("M-n" . move-text-down))
  :config (move-text-default-bindings))
    #+end_src
*** Multi-term
    #+begin_src emacs-lisp :tangle yes
(use-package multi-term
  :bind (("C-x T T" . multi-term)
         ("C-c C-n" . multi-term-next)
         ("C-c C-p" . multi-term-prev))
  :init
  (defun jr/term-mode-hook ()
    (copy-face 'default 'term-face)
    (yas-minor-mode -1)
    (auto-fill-mode -1)
    (compilation-shell-minor-mode t))
  :config
  (progn
    (setq multi-term-program "/bin/bash"
          multi-term-buffer-name "term"
          term-unbind-key-list '("C-x"
                                 "C-h"
                                 "M-x"
                                 "C-z")
          multi-term-scroll-to-bottom-on-output t)
    (cl-flet ((set-color (pair)
                         (multiple-value-bind (face color)
                             pair
                           (set-face-attribute face
                                               nil
                                               :foreground color
                                               :background nil))))
      (mapc #'set-color
            '((term-color-black "#2e3434")
              (term-color-red "tomato")
              (term-color-green "#6ac214")
              (term-color-yellow "#edd400")
              (term-color-blue "light sky blue")
              (term-color-magenta "magenta")
              (term-color-cyan "cyan")
              (term-color-white "#eeeeec"))))
    (setq-default ansi-term-color-vector
                  [term-face
                   term-color-black
                   term-color-red
                   term-color-green
                   term-color-yellow
                   term-color-blue
                   term-color-magenta
                   term-color-cyan
                   term-color-white])
    (add-hook 'term-mode-hook 'jr/term-mode-hook)
    (define-key term-raw-map (kbd "C-c C-n") 'multi-term-next)
    (define-key term-raw-map (kbd "C-c C-p") 'multi-term-prev)))
    #+end_src
*** C++
    #+begin_src emacs-lisp :tangle yes
(use-package irony
  :init
  (add-hook 'c++-mode-hook 'irony-mode)
  :config
  (defun jr/irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async)
    (setq company-backends (delete 'company-semantic company-backends))
    (setq-local eldoc-documentation-function #'ggtags-eldoc-function))
  (add-hook 'irony-mode-hook 'jr/irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

(use-package company-c-headers
  :config
  (progn
    (add-to-list 'company-c-headers-path-system "/usr/include/c++/8.2.1/")
    (add-to-list 'company-backends 'company-c-headers)))
    #+end_src

*** Octave
    [[https://www.gnu.org/software/octave/][GNU Octave]] is a powerful programming language for scientific
    computing. Its syntax is largely compatible with Matlab alongside a
    few improvements.
    #+begin_src emacs-lisp :tangle yes
(use-package octave
  :ensure nil
  :mode "\\.m\\'"
  :config
  (progn
    (setq inferior-octave-startup-args '("-i" "--no-line-editing" "-q" "--braindead" "--no-gui"))
    (add-hook 'inferior-octave-mode-hook
              (lambda ()
                (define-key inferior-octave-mode-map [up]
                  'comint-previous-input)
                (define-key inferior-octave-mode-map [down]
                  'comint-next-input)))))
    #+end_src
*** Scala
    Configuration for the [[https://www.scala-lang.org/][Scala]] programming language leveraging [[https://www.scala-sbt.org/index.html][sbt]] and [[https://scalameta.org/metals/][metals]].
    #+begin_src emacs-lisp :tangle yes
(use-package scala-mode
  :mode "\\.s\\(cala\\|bt\\)$")

(use-package lsp-metals
  :after lsp)

(use-package sbt-mode
  :commands sbt-start sbt-command
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map))
    #+end_src
**** Build metals-emacs
     Per the [[https://scalameta.org/metals/docs/editors/emacs.html][metals documentation]], we should use [[https://github.com/coursier/coursier][coursier]] to build the
     metals-emacs binary.
     #+begin_src bash :results none
cd ~/bin
curl -L -o coursier https://git.io/coursier-cli
chmod +x coursier
./coursier bootstrap \
           --java-opt -Xss4m \
           --java-opt -Xms100m \
           --java-opt -Dmetals.client=emacs \
           org.scalameta:metals_2.12:0.9.7 \
           -r bintray:scalacenter/releases \
           -r sonatype:snapshots \
           -o ~/bin/metals-emacs -f
     #+end_src

*** Typescript
#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :init
  (defun jr/lsp-typescript-mode ()
    (lsp-deferred)
    (require 'dap-node)
    (dap-node-setup))
  :mode "\\.ts\\'"
  :hook (typescript-mode . jr/lsp-typescript-mode)
  :config
  (setq typescript-indent-level 2))
#+end_src
*** JSON mode
#+begin_src emacs-lisp :tangle yes
(use-package json-mode
  :mode "\\.json\\'"
  :custom
  (json-reformat:indent-width 2)
  (js-indent-level 2))
#+end_src
* Gnus
  [[https://www.emacswiki.org/emacs/GnusTutorial][Gnus]] is my preferred e-mail reader.
  It takes a while to get it used to it all (similar to emacs
  actually) but it more than pays off at the end. Here's [[http://www.gnus.org/manual.html][the manual]].
  #+begin_src emacs-lisp :tangle yes
;; (let ((gnus-config-file (expand-file-name "settings/gnus-init.el" user-emacs-directory)))
;;   (when (file-exists-p gnus-config-file)
;;     (setq gnus-init-file gnus-config-file)))
(setq jr/gnus-config-file (expand-file-name "site-lisp/dot-gnus/dot-gnus.org" user-emacs-directory))

(when (file-exists-p jr/gnus-config-file)
  (setq gnus-init-file
        (if (fboundp 'jr/org-babel-tangle-file-if-needed)
            (jr/org-babel-tangle-file-if-needed jr/gnus-config-file)
          (car (org-babel-tangle-file jr/gnus-config-file)))))
  #+end_src

  Let's set gnus as our mail handler
  #+begin_src emacs-lisp :tangle yes
(setq mail-user-agent 'gnus-user-agent)
  #+end_src

  In the rare occasion that I create a new mail via C-x m and gnus
  isn't open, I want to start gnus up first:
  #+begin_src emacs-lisp :tangle yes
(defun jr/start-gnus-maybe (&rest args)
  "Start gnus if it isn't currently running."
  (unless (gnus-alive-p)
    (message "Starting Gnus...")
    (save-excursion
      (let ((inhibit-redisplay t))
        (gnus)))))

(advice-add 'compose-mail :before #'jr/start-gnus-maybe)
  #+end_src

  #+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x g") 'gnus)
  #+end_src

* Org Mode
  When all else fails, [[https://orgmode.org/][org mode]] will work. I use it for almost
  everything, including, of course, writing this document.
  Here's [[https://orgmode.org/manual/][the manual]].

  I have moved my entire org-mode configuration to its own repository
  under https://github.com/jeko2000/dot-org.
  #+begin_src emacs-lisp :tangle yes
(let ((org-config-file (expand-file-name "site-lisp/dot-org/dot-org.org" user-emacs-directory)))
  (when (file-exists-p org-config-file)
    (org-babel-load-file org-config-file nil)))
  #+end_src

* Solutions
** Find file as sudo
   Recently, I've had to edit a great deal of root-level files. This
   function will reopen a given file with superuser priviledges.
   #+begin_src emacs-lisp :tangle yes
(defun jr/reopen-as-sudo ()
  "Kill current buffer and open its file with augmented priviledges."
  (interactive)
  (let ((filename (buffer-file-name)))
    (unless filename
      (error "No file associated with current buffer."))
    (find-alternate-file (concat "/sudo::" filename))))

(bind-key "C-. s" 'jr/reopen-as-sudo)
   #+end_src
** Window splitting
   The following functions allow you to split and switch to a window at once.
   #+begin_src emacs-lisp :tangle yes
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(bind-key "C-x 2" 'vsplit-other-window)
(bind-key "C-x 3" 'hsplit-other-window)
   #+end_src
** Less intrusive visible bell
   #+begin_src emacs-lisp :tangle yes
(defun jr/flash-mode-line ()
  "Invert the mode-line face briefly.
This can be used as a friendlier visual bell effect.
Source: EmacsWiki"
  (invert-face 'mode-line)
  (run-with-timer 0.1 nil 'invert-face 'mode-line))

(setq visible-bell nil
      ring-bell-function #'jr/flash-mode-line)
   #+end_src
** PKGBUILD files
   #+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("PKGBUILD" . shell-script-mode))
   #+end_src
** Hungry delete
   #+begin_src emacs-lisp :tangle yes
(defun contextual-backspace ()
  "Hungry whitespace or delete word depending on context."
  (interactive)
  (if (looking-back "[[:space:]\n]\\{2,\\}" (- (point) 2))
      (while (looking-back "[[:space:]\n]" (- (point) 1))
        (delete-char -1))
    (cond
     ((and (boundp 'smartparens-strict-mode)
           smartparens-strict-mode)
      (sp-backward-kill-word 1))
     ((and (boundp 'subword-mode)
           subword-mode)
      (subword-backward-kill 1))
     (t
      (backward-kill-word 1)))))

(global-set-key (kbd "C-<backspace>") 'contextual-backspace)
   #+end_src
** Regex helpers
   #+begin_src emacs-lisp :tangle yes
(use-package re-builder
  :ensure nil
  ;; C-c C-u errors, C-c C-w copy, C-c C-q exit
  :init (bind-key "C-c r" 're-builder emacs-lisp-mode-map))

(use-package pcre2el
  :commands rxt-toggle-elisp-rx
  :init (bind-key "C-c / t" 'rxt-toggle-elisp-rx emacs-lisp-mode-map))

   #+end_src
** Indentation
   #+begin_src emacs-lisp :tangle yes
(defun indent-buffer ()
  "Indent the entire buffer."
  (interactive)
  (save-excursion
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max))))
   #+end_src
** Copy current file
#+begin_src emacs-lisp :tangle yes
(defun jr/kill-append-buffer-file-name ()
  (interactive)
  (when-let ((buf (buffer-file-name)))
    (message "Added %s to kill-ring" buf)
    (kill-new buf)))

(global-set-key (kbd "C-c e n") #'jr/kill-append-buffer-file-name)
#+end_src
** Indent whole buffer if no region is selected
#+begin_src emacs-lisp :tangle yes
(defun jr/indent-region-or-buffer ()
  (interactive)
  (save-excursion 
    (cond ((region-active-p)
           (indent-region (region-beginning) (region-end))
           (message "Indented region"))
          (t
           (indent-region (point-min) (point-max))
           (message "Indented buffer")))))


(global-set-key (kbd "C-M-\\") #'jr/indent-region-or-buffer)
#+end_src
** Global key for sorting lines
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c e S") #'sort-lines)
#+end_src
* Footer
  #+begin_src emacs-lisp :tangle yes
(message "Emacs config.el end")
  #+end_src
