#+TITLE: Emacs Configuration
#+AUTHOR: Johnny Ruiz
#+EMAIL: jeko2000@yandex.com
#+LANGUAGE: en

* Header
  #+begin_src emacs-lisp :tangle yes
(message "Emacs config.el started at %s" (current-time-string))
  #+end_src
  #+begin_src emacs-lisp :tangle yes
;; We set a few variables we use for dispatching
(defconst jr/display-p (display-graphic-p)
  "Value is t when the current display is a graphical display.")

(defconst jr/macos-p (eq system-type 'darwin)
  "Value is t when current operating system is Darwin/macOS.")

(defconst jr/gnu-linux-p (eq system-type 'gnu/linux)
  "Value is t when current operating system is GNU/Linux.")
  #+end_src
* Look and Feel
** Basic GUI
   Remove GUI elements geared to mouse usage.
   This will maximize the screen space for our buffers.
   #+begin_src emacs-lisp :tangle yes
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(setq visible-cursor nil
      inhibit-startup-message t
      initial-scratch-message "")
   #+end_src
** Themes
   The manual defines [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Custom-Themes.html][Custom Themes]] as a collections of settings that can
   be enabled or disabled as a unit. However, for this section the term
   =theme= refers to a =color theme=.
   Themes are loaded using the `load-theme' function. Yet, when this function is
   called multiple times within the same emacs session, it's possible for themes
   to inadvertently inherit settings from previously themes.

   The desired behavior is for any currently active custom theme to be disabled
   prior to loading a new theme.

   The following function, taken almost verbatim from [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's configuration]],
   first asks the user to select a theme from a list of currently available themes,
   then it disables all curently enabled custom themes before finally loading the
   chosen theme.
   #+begin_src emacs-lisp :tangle yes
(defun switch-theme (theme)
  "Load THEME after disabling all curently loaded themes."
  (interactive
   (list (intern (completing-read
                  "Load custom theme: "
                  ;; we pass a list of available themes as strings
                  (mapcar 'symbol-name (custom-available-themes))))))
  (dolist (enabled-theme custom-enabled-themes)
    (disable-theme enabled-theme))
  (load-theme theme 'no-confirm))
;; The `bind-key' macro is part of use-package which is loaded as part
;; of init.el
(bind-key "s-<f12>" 'switch-theme)
   #+end_src
*** Nord
    The [[https://www.nordtheme.com][Nord]] color theme is a dark bluish palette great for readibility.
    #+html: <p align="center"><a href="https://www.nordtheme.com/ports/emacs" target="_blank"><img src="https://raw.githubusercontent.com/arcticicestudio/nord-docs/develop/assets/images/ports/emacs/overview-go.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package nord-theme
  :if jr/display-p)
    #+end_src
    -----
*** Zenburn
    [[http://kippura.org/zenburnpage/][Zenburn]] is a low contrast theme originally written for Vim.
    #+html: <p align="center"><a href="http://kippura.org/zenburnpage/" target="_blank"><img src="http://kippura.org/i/zenburn.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package zenburn-theme
  :if jr/display-p)
    #+end_src
    -----
*** Solarized theme
    The [[https://github.com/bbatsov/solarized-emacs][Solarized colour theme]] is a port by [[https://github.com/bbatsov][Bozhidar Batsov (bbatsov)]] from
    the original [[http://ethanschoonover.com/solarized][Solarized theme by Ethan Schoonover]].
    #+html: <p align="center"><a href="http://ethanschoonover.com/solarized" target="_blank"><img src="https://raw.githubusercontent.com/altercation/solarized/master/img/solarized-vim.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package solarized-theme
  :if jr/display-p
  :config
  (setq solarized-distinct-fringe-background t)
  (setq x-underline-at-descent-line t))
    #+end_src
    -----
*** Monokai theme
    The [[https://github.com/oneKelvinSmith/monokai-emacs][Monokai theme]] is a port by [[https://github.com/oneKelvinSmith][Kelvin Smith (oneKelvinSmith)]] from the
    original [[https://www.monokai.pro/][TextMate theme Monokai by Wimer Hazenberg]].
    #+html: <p align="center"><a href="https://monokai.pro" target="_blank"><img src="https://raw.githubusercontent.com/oneKelvinSmith/monokai-emacs/master/assets/monokai_0.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package monokai-theme
  :if jr/display-p
  :config
  (setq monokai-use-variable-pitch nil))
    #+end_src
    -----
*** E-Ink
    [[https://github.com/maio/eink-emacs][Low distraction, minimalistic color theme]] for Emacs emulating reading
    on E Ink devices by [[https://github.com/maio][Marian Schubert maio]].
    #+html: <p align="center"><a href="https://github.com/maio/eink-emacs" target="_blank"><img src="https://raw.githubusercontent.com/maio/eink-emacs/master/images/example.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package eink-theme
  :if jr/display-p)
    #+end_src
    -----
*** Material theme
    The [[https://github.com/cpaulik/emacs-material-theme][Material theme]] is based on the colors proposed by the [[http://www.google.com/design/spec/style/color.html#color-color-palette][Google
    Maerial Design]] put together by [[https://github.com/cpaulik/][Christoph Paulik cpaulik]]
    #+html: <p align="center"><a href="http://www.google.com/design/spec/style/color.html#color-color-palette" target="_blank"><img src="https://github.com/cpaulik/emacs-material-theme/blob/master/material-theme.png?raw=true"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package material-theme
  :if jr/display-p)
    #+end_src
    -----
*** Tango theme
    Implementation of the [[http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines][Tango Desktop project palette]] by [[https://github.com/juba][Julien Barnier juba]]
    #+html: <p align="center"><a href="https://github.com/juba" target="_blank"><img src="https://raw.githubusercontent.com/juba/color-theme-tangotango/master/screenshots/tangotango_elisp.png"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package tangotango-theme
  :if jr/display-p)
    #+end_src
    -----
*** Waher
    #+html: <p align="center"><a href="https://github.com/emacsfodder/emacs-waher-theme" target="_blank"><img src="https://camo.githubusercontent.com/b3d3d57f542d19104c0c20495bdf7864292920ec/68747470733a2f2f7261772e6769746875622e636f6d2f6a61736f6e6d32332f656d6163732d77616865722d7468656d652f6d61737465722f77616865722d7468656d652e706e67"/></a></p>
    #+begin_src emacs-lisp :tangle yes
(use-package waher-theme
  :if jr/display-p)
    #+end_src
*** Theme of choice
    #+begin_src emacs-lisp :tangle yes
(defvar jr/default-theme 'nord
  "Default theme to be loaded as part of the initial
configuration.")

(when (and jr/display-p
           (member jr/default-theme (custom-available-themes)))
  (switch-theme jr/default-theme))
    #+end_src
** Fonts
   Current fonts of choice:
   #+begin_src emacs-lisp :tangle yes
(let ((available-fonts (font-family-list)))
  (cond
   ((member "Inconsolata" available-fonts)
    (set-face-attribute 'default nil :font "Inconsolata" :height 160))
   ((member "DejaVu Sans Mono" available-fonts)
    (set-face-attribute 'default nil :font "DejaVu Sans Mono" :height 140))))

(global-prettify-symbols-mode 1)
   #+end_src
* Sane Defaults
  These come largely from configurations by [[https://github.com/magnars/.emacs.d][Magnars Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha
  Chua]].

  #+begin_src emacs-lisp :tangle yes
;; Enable some disabled functions
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternative-file 'disabled nil)

;; Blink cursor
(blink-cursor-mode 1)
(setq blink-cursor-blinks 0)

;; UTF-8 settings
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

;; Line numbers
(setq line-number-mode t
      line-number-display-limit nil
      line-number-display-limit-width 30)

;; Column settings
(setq column-number-mode t
      fill-column 80)

;; Windows resizing
(bind-key "s-C-<left>" 'shrink-window-horizontally global-map)
(bind-key "s-C-<right>" 'enlarge-window-horizontally global-map)
(bind-key "s-C-<down>" 'shrink-window global-map)
(bind-key "s-C-<up>" 'enlarge-window global-map)

;; Next, I find that every once in a while I hit "C-z", `suspend-frame'
;; by accident and it takes me a couple of seconds to realize what
;; happened. I think this is rather annoying so let's unbind it here:
(define-key global-map (kbd "C-z") nil)

(if (>= emacs-major-version 24)
    (setq select-enable-clipboard t)
  (setq x-select-enable-clipboard t))

(setq echo-keystrokes 0.2
      shift-select-mode nil
      jump-char-lazy-highlight-face nil
      eval-expression-print-level nil
      visible-bell nil
      enable-recursive-minibuffers t
      gc-cons-threshold 20000000)

(setq-default indent-tabs-mode nil
	      indicate-empty-lines t
	      truncate-lines t
	      sentence-end-double-space nil)

(transient-mark-mode 1)
(make-variable-buffer-local 'transient-mark-mode)
(auto-compression-mode t)

(defalias 'yes-or-no-p 'y-or-n-p)

(use-package uniquify
  :ensure nil
  :config
  (setq uniquify-buffer-name-style 'forward))

(use-package savehist
  :ensure nil
  :config
  (progn
    (savehist-mode 1)
    (setq history-length 1000)))

(use-package font-lock
  :ensure nil
  :config
  (global-font-lock-mode t))

;; When popping the mark, continue popping until the cursor actually moves
;; Also, if the last command was a copy - skip past all the expand-region cruft.
(defadvice pop-to-mark-command (around ensure-new-position activate)
  (let ((p (point)))
    (when (eq last-command 'save-region-or-current-line)
      ad-do-it
      ad-do-it
      ad-do-it)
    (dotimes (i 10)
      (when (= p (point)) ad-do-it))))
(setq set-mark-command-repeat-pop t)

;; Offer to create parent directories if they do not exist
;; http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/
(defun jr/create-non-existent-directory ()
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
	       (y-or-n-p (format "Directory `%s' does not exist! Create it recursively?" parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions 'jr/create-non-existent-directory)

;; autosave
(let ((backups (expand-file-name "backups" user-emacs-directory))
      (auto-save-list (expand-file-name "auto-save-list/" user-emacs-directory)))
  (setq backup-directory-alist `(("." . ,backups))
	auto-save-file-name-transforms `((".*" ,auto-save-list t))
	make-backup-files t
	backup-by-copying t
	version-control t
	delete-old-versions t
	delete-by-moving-to-trash t
	kept-old-versions 12
	kept-new-versions 12
	auto-save-default t
	auto-save-timeout 10
	auto-save-interval 100))
(if (>= emacs-major-version 24)
    (setq select-enable-clipboard t)
  (setq x-select-enable-clipboard t))
  #+end_src

  From [[info:eintr#Loops%20&%20Recursion][info:eintr#Loops & Recursion]]

  #+begin_src emacs-lisp :tangle yes
(setq max-specpdl-size 20000
      max-lisp-eval-depth 30000)
  #+end_src

  Let's update auth-sources for our configuration. In particular, let's
  test if a [[https://github.com/syncthing/syncthing][Syncthing]] folder exists in the file system and if so, add 
  #+begin_src emacs-lisp :tangle yes
(setq auth-sources '( "~/.authinfo.gpg"
                      "~/.authinfo"
                      "~/.netrc"))

(let ((syncthing-auth-source "~/Sync/all/.authinfo.gpg"))
  (when (file-exists-p syncthing-auth-source)
    (add-to-list 'auth-sources syncthing-auth-source)))
  #+end_src

  As pointed out in [[http://puntoblogspot.blogspot.com/2018/10/kill-ring-max-is-thing.html][here]], we can increase the value of kill-ring-max to
  allow for a larger kill-ring
  #+begin_src emacs-lisp :tangle yes
(setq kill-ring-max 180)
  #+end_src

  Let's make it a bit harder to quit out of emacs
  #+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x C-c") nil)
(global-set-key (kbd "C-x r q") 'save-buffers-kill-terminal)
  #+end_src
* Non-programming packages
** LSP
   #+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :config
  (progn
    (setq lsp-log-io nil
          lsp-auto-guess-root nil
          lsp-eldoc-enable-hover t
          lsp-eldoc-render-all t
          lsp-enable-file-watchers t
          lsp-enable-folding nil
          lsp-enable-indentation t
          lsp-enable-xref t
          lsp-prefer-flymake nil)))

(use-package lsp-ui
  :after lsp-mode
  :init (defun jr/lsp-ui-mode-hook ()
          (lsp-ui-flycheck-enable t))
  :hook ((lsp-mode . lsp-ui-mode)
         (lsp-ui-mode . jr/lsp-ui-mode-hook))
  :config
  (setq lsp-ui-doc-enable t
        lsp-ui-doc-alignment 'window
        lsp-ui-doc-delay 0.5
        lsp-ui-doc-header nil
        lsp-ui-doc-include-signature t
        lsp-ui-doc-position 'at-point
        lsp-ui-doc-use-childframe nil
        lsp-ui-flycheck-enable t
        lsp-ui-flycheck-list-position 'right
        lsp-ui-flycheck-live-reporting t
        lsp-ui-peek-enable t
        lsp-ui-peek-always-show nil
        lsp-ui-peek-fontify t
        lsp-ui-peek-show-directory t
        lsp-ui-imenu-enable nil
        lsp-ui-sideline-enable t
        lsp-ui-sideline-delay 1
        lsp-ui-sideline-ignore-duplicate t
        lsp-ui-sideline-show-symbol t
        lsp-ui-sideline-show-hover t
        lsp-ui-sideline-showcode-actions t
        lsp-ui-sideline-update-mode 'point))

(use-package company-lsp
  :after company
  :init
  (defun jr/company-lsp-hook ()
    (setq company-idle-delay 0.3))
  :config
  (progn
    (add-hook 'lsp-mode-hook #'jr/company-lsp-hook)
    (push 'company-lsp company-backends)
    (setq company-lsp-cache-candidates 'auto
          company-lsp-async t
          company-lsp-enable-snippet t
          company-lsp-enable-recompletion t)))
   #+end_src
** exec-path-from-shell
   #+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns x))
  :config
  (progn
    (exec-path-from-shell-copy-env "JAVA_HOME")
    (exec-path-from-shell-initialize)))
   #+end_src

** delight
   Quoting directly from the [[https://www.emacswiki.org/emacs/DelightedModes][wiki]], Delight enables you to easily
   customize how major and minor modes appear in the ModeLine.
   #+begin_src emacs-lisp :tangle yes
(use-package delight
  :config
  (delight '((abbrev-mode " Abv" abbrev)
             (auto-fill-function nil t)
             (auto-fill-mode nil t)
             (eldoc-mode nil eldoc)
             (emacs-lisp-mode "Elisp" :major)
             (erc-mode "i" :major)
             (org-mode "O" :major)
             (org-agenda-mode "Agenda" :major)))
  (if (window-system)
      (delight '((erc-mode "ι" :major)
                 (org-mode "Ω" :major)
                 (emacs-lisp-mode "ξ" :major)))))
   #+end_src
** subword
   [[http://wikemacs.org/wiki/Subword-mode][Subword]] mode allows navigation commands to be aware of words in
   [[https://en.wikipedia.org/wiki/Camel_case][camelCase]].
   #+begin_src emacs-lisp :tangle yes
(use-package subword
  :ensure nil
  :delight
  :config
  (global-subword-mode 1))
   #+end_src

** Winner mode
   [[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] allows to 'undo' and 'redo' on window configurations.
   Say you have 5 windows open carefully positioned and then you focus on
   just one via 'C-x 1' or equivalent. How do you get back to the
   original configuration? Well... with winner-undo.
   #+begin_src emacs-lisp :tangle yes
(use-package winner
  :ensure nil
  :bind (("C-c <left>" . winner-undo)
         ("C-c <right>" . winner-redo))
  :config
  (winner-mode 1))
   #+end_src

   The following allows for a quick transposition if you have multiple frames.
   #+begin_src emacs-lisp :tangle yes
(use-package transpose-frame
  :bind ("C-s-t" . transpose-frame))
   #+end_src
   [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] allows you to navigate around a window or frame by
   prompting you for a character and then showing keys to navigate
   directly to it.
   #+begin_src emacs-lisp :tangle yes
(use-package ace-jump-mode
  :commands ace-jump-mode
  :bind (("C-S-s" . ace-jump-mode)
         ("s-s" . ace-jump-mode)))
   #+end_src
** Password store
   Password store allows to you to interface with the [[https://www.passwordstore.org/][pass]] password
   manager.
   #+begin_src emacs-lisp :tangle yes
(use-package password-store
  :if (file-exists-p "~/.password-store")
  :bind ("C-c s c" . password-store-copy))
   #+end_src

** Recentf
   I visit the sames files often. [[https://www.emacswiki.org/emacs/RecentFiles][Recent Files]] allows one to build a list
   of such files for easy access
   #+begin_src emacs-lisp :tangle yes
(use-package recentf
  :ensure nil
  :config
  (progn
    (recentf-mode 1)
    (setq recentf-max-saved-items 100)))
   #+end_src

** Tramp
   Of course! We need [[https://www.gnu.org/software/tramp/][remote file editing!]]
   #+begin_src emacs-lisp :tangle yes
(use-package tramp
  :ensure nil
  :defer 10)
   #+end_src

** PDF-Tools
   [[https://github.com/politza/pdf-tools][Alternative to DocView for PDF files]]. Requires initial setup though.
   #+begin_src emacs-lisp :tangle yes
(use-package pdf-tools
  :init
  (when (condition-case nil
            (progn (pdf-info-check-epdfinfo) t)
          (error nil))
    (add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdf-view-mode))))
   #+end_src
** Undo Tree
   [[https://www.emacswiki.org/emacs/UndoTree][Undo Tree]] tries to improve on emacs undo system by helping you
   visualize actions.
   #+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :bind
  ("C-x u" . undo-tree-visualize)
  :config
  (progn
    (setq undo-tree-mode-lighter ""
          undo-tree-visualizer-diff t
          undo-tree-visualizer-timestamps t)
    (global-undo-tree-mode)))
   #+end_src

** Display Battery & Clock modes
   I like to run all my emacs frames at full-screen. The problem comes
   when my laptop dies because I didn't bother to check the status of its
   battery. [[https://www.emacswiki.org/emacs/DisplayBatteryMode][Display Battery Mode]] can show the status of the system
   battery right on the mode line.
   #+begin_src emacs-lisp :tangle yes
(when (functionp 'display-battery-mode)
  (setq battery-mode-line-format "[%b%p%% %t]")
  (display-battery-mode 1))
   #+end_src
   Along the same lines, I like to be able to check the time from within a
   full-screen frame.
   #+begin_src emacs-lisp :tangle yes
(when (functionp 'display-time-mode)
  (setq display-time-format " h:%H:%M"
        display-time-day-and-date nil
        display-time-default-load-average nil
        display-time-interval 60
        display-time-mail-string "")
  (display-time-mode 1))
   #+end_src
** Zoom-frm
   My main machine has a very high resolution which makes font size
   appear very small for my rather weak eyes. The [[https://www.emacswiki.org/emacs/zoom-frm.el][zoom-frm]] packages from
   the [[https://www.emacswiki.org/][EmacsWiki]] provides a way to increase font size evenly across the
   frame.

   I add an advice to the switch-theme function to zoom in to my desired
   zoom. Similarly, I add a hook to do the same when I create new frames.
   #+begin_src emacs-lisp :tangle yes
(unless (package-installed-p 'zoom-frm)
  (let ((site-lisp-dir (expand-file-name "site-lisp/" user-emacs-directory)))
    (with-temp-buffer
      (insert-file-contents (expand-file-name "frame-fns.el" site-lisp-dir))
      (package-install-from-buffer))
    (with-temp-buffer
      (insert-file-contents (expand-file-name "frame-cmds.el" site-lisp-dir))
      (package-install-from-buffer))
    (with-temp-buffer
      (insert-file-contents (expand-file-name "zoom-frm.el" site-lisp-dir))
      (package-install-from-buffer))))

(use-package zoom-frm
  :demand t
  :if (and window-system
           (package-installed-p 'zoom-frm))
  :bind (("C-M-=" . zoom-in/out)
         ("H-z"   . toggle-zoom-frame)
         ("s-<f1>" . toggle-zoom-frame))
  :init
  (setq jr/zoom-frm-zoom
        (or (and (boundp 'jr/zoom-frm-desired-zoom)
                 jr/zoom-frm-desired-zoom)
            1))
  (defun jr/zoom-in-on-frame (frame)
    (with-selected-frame frame
      (zoom-in/out jr/zoom-frm-zoom)))
  (defun jr/zoom-in-on-all-frames ()
    (mapc #'jr/zoom-in-on-frame (frame-list)))
  :config
  (progn
    (jr/zoom-in-on-all-frames)
    (setq frame-zoom-font-difference 10)
    (advice-add 'switch-theme :after (lambda (theme)
                                       (jr/zoom-in-on-all-frames)))
    (add-hook 'after-make-frame-functions #'jr/zoom-in-on-frame)))
   #+end_src

** BBDB
   [[https://www.emacswiki.org/emacs/CategoryBbdb][The Insidious Big Brother Database]] provides an address book that hooks
   to [[https://www.emacswiki.org/emacs/GnusTutorial][Gnus]].
   #+begin_src emacs-lisp :tangle yes
;;TODO: Groom BBDB
(use-package bbdb
  :config
  (progn
    (setq bbdb-complete-name-full-completion t
          bbdb-completion-type 'primary-or-name
          bbdb-complete-name-allow-cycling t)
    (setq
     bbdb-offer-save 1                        ;; 1 means save-without-asking

     bbdb-use-pop-up t                        ;; allow popups for addresses
     bbdb-electric-p t                        ;; be disposable with SPC
     bbdb-popup-target-lines  1               ;; very small
     bbdb-dwim-net-address-allow-redundancy t ;; always use full name
     bbdb-quiet-about-name-mismatches 2       ;; show name-mismatches 2 secs
     bbdb-always-add-address t                ;; add new addresses to existing...
     ;; ...contacts automatically
     bbdb-canonicalize-redundant-nets-p t     ;; x@foo.bar.cx => x@bar.cx
     bbdb-completion-type nil                 ;; complete on anything
     bbdb-complete-name-allow-cycling t       ;; cycle through matches
     bbbd-message-caching-enabled t           ;; be fast
     bbdb-use-alternate-names t               ;; use AKA
     bbdb-elided-display t                    ;; single-line addresses
     )
    (add-hook 'message-mode-hook
              '(lambda ()
                 (bbdb-initialize 'gnus 'message)
                 (local-set-key "<TAB>" 'bbdb-complete-name)))
    (add-hook 'bbdb-initialize-hook
              '(lambda ()
                 (setq compose-mail-user-agent-warnings nil)))))
   #+end_src
** Epub - Nov
   [[https://github.com/wasamasa/nov.el][Nov]] mode provides a major mode for reading [[https://en.wikipedia.org/wiki/EPUB][EPUB]] documents.
   #+begin_src emacs-lisp :tangle yes
(use-package nov
  :mode ("\\.epub\\'" . nov-mode))
   #+end_src
** w3m
   [[http://w3m.sourceforge.net/][W3m]] is a text-based browser whose engine is used by emacs to serve
   HTML pages. [[http://emacs-w3m.namazu.org][Ensure you have w3m installed]].
   We also add a couple of bindings to open urls externally through
   Firefox.
   #+begin_src emacs-lisp :tangle yes
(use-package w3m
  :if (executable-find "w3m")
  :bind ("C-x w" . 'w3m)
  :defer t
  :config
  (progn
    ;;    (setq w3m-user-agent "Mozilla/5.0 (Linux; U; Android 2.3.3; zh-tw; HTC_Pyramid Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.")
    (setq browse-url-browser-function 'w3m-goto-url-new-session)
    (setq w3m-home-page "https://duckduckgo.com/lite/")
    (defun jr/w3m-open-link-at-point-in-firefox ()
      "Open the w3m anchor at point in Firefox."
      (interactive)
      (browse-url-firefox (w3m-anchor)))
    (defun jr/w3m-open-current-url-in-firefox ()
      "Open the `w3m-current-url' in Firefox"
      (interactive)
      (browse-url-firefox w3m-current-url))
    (define-key w3m-mode-map "X" 'jr/w3m-open-link-at-point-in-firefox)
    (define-key w3m-mode-map "x" 'jr/w3m-open-current-url-in-firefox)))
   #+end_src
** Olivetti
   [[https://github.com/rnkn/olivetti][Olivetti]] mode provides a nice environment to write distraction-free.
   #+begin_src emacs-lisp :tangle yes
(use-package olivetti
  :defer t
  :config
  (setq olivetti-body-width 120))
   #+end_src
** Synosaurus
   When writing papers or long emails, it's convenient to have a
   thesaurus right in emacs. The package [[https://github.com/hpdeifel/synosaurus][synosaurus]] wraps around the
   wordnet executable to provide just that functionality.

   Here, we first check if the wordnet executable, wn, is found in the
   PATH and then proceed to download and configure synosaurus.

   One item to note is that sunosaurus defaults to using "C-c C-s" for its
   commands, which is inconvenient in Org mode since "C-c C-s" is Org's
   default binding for org-schedule. Before we load the package, we set
   the prefix to "C-c s" instead.

   #+begin_src emacs-lisp :tangle yes
(use-package synosaurus
  :if (executable-find "wn")
  :delight
  :hook (text-mode . synosaurus-mode)
  :init
  (setq synosaurus-prefix (kbd "C-c s"))
  :config
  (setq synosaurus-backend 'synosaurus-backend-wordnet
        synosaurus-choose-method 'default))
   #+end_src

** Diminish
   Update: I no longer use [[https://github.com/myrjola/diminish.el][diminish]] and have switched to [[https://www.emacswiki.org/emacs/DelightedModes][delight]] instead.
   #+begin_src emacs-lisp :tangle no
(eval-after-load "subword" '(diminish 'subword-mode))
   #+end_src
** Neotree
   The [[https://github.com/jaypei/emacs-neotree][neotree]] package provides a file system tree similar to NerdTree
   for Vim.

   Per the neotree [[https://github.com/jaypei/emacs-neotree/blob/dev/README.md][README]] file, we must install the [[https://github.com/domtronn/all-the-icons.el][all-the-icons]] package
   and its fonts before the icons theme works properly.
   #+begin_src emacs-lisp :tangle yes
(use-package neotree
  :commands neotree-toggle
  :config
  (progn
    (global-set-key [f8] 'neotree-toggle)
    (use-package all-the-icons)
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow)
          neo-smart-open t
          projectile-switch-project-action 'neotree-projectile-action)))
   #+end_src
** ace-window
   The [[https://github.com/abo-abo/ace-window][ace-window]] by [[ace-window][abo-abo]] offers an improved way of navigating through
   multiple windows. As part of its configuration, let's have it use the
   keys from the home row instead of the numbers 1-9.
   #+begin_src emacs-lisp :tangle yes
(use-package ace-window
  :bind ("M-o" . 'ace-window)
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
        aw-background nil))
   #+end_src
** erc
   #+begin_src emacs-lisp :tangle yes
;; This causes ERC to connect to the Freenode network upon hitting
;; C-c e f.  Replace MYNICK with your IRC nick.
(use-package erc
  :ensure nil
  :delight erc-mode "ε"
  :defer t
  :config
  (progn
    (add-to-list 'erc-modules 'notifications)
    (add-to-list 'erc-modules 'spelling)
    (erc-services-mode 1)
    (erc-update-modules)
    (setq erc-autojoin-channels-alist '(("freenode.net" "#emacs" "#erc"
                                         "#gnus" "#org-mode #i3" "#archlinux"))
          erc-autojoin-timing 'ident
          erc-autojoin-delay 10
          erc-fill-function 'erc-fill-static
          erc-fill-static-center 22
          erc-fill-function 'erc-fill-variable
          erc-hide-list '("JOIN" "PART" "QUIT")
          erc-lurker-hide-list '("JOIN" "PART" "QUIT")
          erc-lurker-threshold-time 43200
          erc-fill-column 78
          erc-rename-buffers t
          erc-insert-timestamp-function 'erc-insert-timestamp-left
          erc-kill-buffer-on-part t
          erc-prompt-for-nickserv-password nil
          erc-server-reconnect-attempts 5
          erc-server-reconnect-timeout 3
          erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
                                    "324" "329" "332" "333" "353" "477"))
    (use-package erc-hl-nicks)
    (use-package erc-image)))
   #+end_src
** elfeed
   [[https://github.com/skeeto][Skeeto]]'s excellent [[https://github.com/skeeto/elfeed][elfeed]] package provides an excellent RSS and Atom
   feed client for emacs.
   #+begin_src emacs-lisp :tangle yes
(use-package elfeed
  :bind ("C-x F" . 'elfeed)
  :defer 10
  :init
  (defmacro jr/elfeed-add-face (face spec doc &rest args)
    "Create a new face elfeed-FACE and push it to the
`elfeed-search-face-alist'."
    (declare (indent 0))
    (let ((elfeed-face-symbol
           (intern (concat "elfeed-" (symbol-name face)))))
      `(progn
         (defface ,elfeed-face-symbol
           ,spec
           ,doc
           ,@ args)
         (push '(,face ,elfeed-face-symbol)
               elfeed-search-face-alist))))
  :config
  (progn
    (setq elfeed-feeds
          '(("https://estamosaquitravel.com/feed.atom" travel estamosaqui)
            ("http://endlessparentheses.com/atom.xml" tech emacs)
            ("http://planet.emacsen.org/atom.xml" tech emacs)
            ("http://nullprogram.com/feed/" tech)
            ("https://felixcrux.com/blog/rss.xml" tech)
            ("https://www.xkcd.com/atom.xml" webcomic)
            ("http://nedroid.com/feed/" webcomic)
            ("https://pthree.org/feed" blog)
            ("http://esr.ibiblio.org/?feed=rss2" blog)
            ("http://blog.cryptographyengineering.com/feeds/posts/default" blog)
            ("http://accidental-art.tumblr.com/rss" image math)
            ("https://www.npr.org/rss/podcast.php?id=510299" audio)
            ("http://english.bouletcorp.com/feed/" comic)
            ("http://bit-player.org/feed" blog math)
            ("http://simblob.blogspot.com/feeds/posts/default" blog dev)
            ("https://utcc.utoronto.ca/~cks/space/blog/?atom" blog dev)
            ("http://www.commitstrip.com/en/feed/" comic dev)
            ("http://feeds.feedburner.com/Buttersafe" comic)
            ("http://feeds.feedburner.com/CatVersusHuman" comic)
            ("http://feeds.feedburner.com/channelATE" comic)
            ("https://lemire.me/blog/feed/" dev blog)
            ("https://danluu.com/atom.xml" dev blog)
            ("https://www.blogger.com/feeds/19727420/posts/default" blog)
            ("https://dendibakh.github.io/feed.xml" blog dev)
            ("https://drewdevault.com/feed.xml" blog dev)
            ("http://dvdp.tumblr.com/rss" image)
            ("https://www.digitalocean.com/blog/feed" blog product)
            ("http://bay12games.com/dwarves/dev_now.rss" blog gaming product)
            ("http://danwang.co/feed/" blog philosophy)))
    (setq url-queue-timeout 20)
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :before "2 weeks ago"
                                  :remove 'unread))
    ;; Faces
    (jr/elfeed-add-face audio
                        '((t :foreground "#FA0"))
                        "Marks podcasts in Elfeed."
                        :group 'elfeed)
    (jr/elfeed-add-face webcomic
                        '((t :foreground "#BFF"))
                        "Marks webcomics in Elfeed."
                        :group 'elfeed)))
   #+end_src
** emacs-server
   #+begin_src emacs-lisp :tangle yes
(use-package server
  :ensure nil
  :config (progn
            (server-start)
            (require 'org-protocol)))
   #+end_src
** appt
   #+begin_src emacs-lisp :tangle yes
(use-package appt
  :ensure nil
  :config
  (progn
    (appt-activate 1)
    (setq appt-audible t
          appt-display-duration 15
          appt-display-format 'window
          appt-display-mode-line t
          appt-message-warning-time 12)))
   #+end_src
** po-edit
   #+begin_src emacs-lisp :tangle yes
(use-package po-mode
  :mode ("\\.pot?\\'" . po-mode))
   #+end_src
** gnuplot
   [[http://www.gnuplot.info/][Gnuplot]] is a portable command-line driven graphing utility supported
   by org mode through Bruce Rave's [[https://github.com/bruceravel/gnuplot-mode][gnuplot-mode]]
   #+begin_src emacs-lisp :tangle yes
(use-package gnuplot
  :if (executable-find "gnuplot")
  :mode (("\\.gpi\\'" . gnuplot-mode)
         ("\\.plt\\'" . gnuplot-mode)
         ("\\.gp\\'" . gnuplot-mode)
         ("\\.gnuplot\\'" . gnuplot-mode)))
   #+end_src

** bongo
   The [[https://github.com/dbrock/bongo][bongo]] package provides a flexible media player for emacs.
   #+begin_src emacs-lisp :tangle yes
(use-package bongo
  :init
  (progn
    (defvar jr/bongo-music-dir
      (or (and (boundp 'jr/bongo-music-directory)
               jr/bongo-music-directory)
          "~")
      "Location of music directory destined to be inserted into the bongo library.")

    (defvar jr/bongo-volume-raise-cmd
      (or (and (boundp 'jr/volume-raise-volume-command)
               jr/volume-raise-volume-command)
          "pactl set-sink-volume @DEFAULT_SINK@ +5%")
      "Shell command to raise system volume.")

    (defvar jr/bongo-volumn-lower-cmd
      (or (and (boundp 'jr/volume-lower-volume-command)
               jr/volume-lower-volume-command)
          "pactl set-sink-volume @DEFAULT_SINK@ -5%")
      "Shell command to lower system volume.")
    (defun jr/bongo-show-current-track ()
      "Display current track in the minibuffer."
      (interactive)
      (with-current-buffer bongo-default-playlist-buffer-name
        (when bongo-player
          (bongo-player-show-infoset bongo-player))))
    (defun jr/volume-raise-volume ()
      "Raise default sink's volume through the shell command
specified by `jr/bongo-volume-raise-cmd'."
      (interactive)
      (shell-command jr/bongo-volume-raise-cmd))
    (defun jr/volume-lower-volume ()
      "Lower default sink's volume through the shell command
specified by `jr/bongo-volumn-lower-cmd'."
      (interactive)
      (shell-command jr/bongo-volumn-lower-cmd))
    (defun jr/bongo-mode-init ()
      (interactive)
      (let ((bongo-insert-whole-directory-trees t))
        (when (file-exists-p jr/bongo-music-dir)
          (bongo-insert-file jr/bongo-music-dir)
          (with-current-buffer (bongo-playlist-buffer)
            (bongo-sprinkle-mode 1)
            (bongo-play))))))

  :bind (("C-c m SPC" . bongo-pause/resume)
         ("C-c m n" . bongo-play-next)
         ("C-c m p" . bongo-play-previous)
         ("C-c m r" . bongo-play-random)
         ("C-c m s" . jr/bongo-show-current-track)
         ("C-c m b" . bongo)
         ("C-c m u" . jr/volume-raise-volume)
         ("C-c m d" . jr/volume-lower-volume))
  :config
  (progn
    (setq
     ;; Drag and drop support
     bongo-dnd-support t
     bongo-dnd-destination 'end-of-buffer
     ;; Lastfm support
     bongo-global-lastfm-mode nil
     ;; File insertion
     bongo-insert-whole-directory-trees 'ask
     bongo-mark-played-tracks t
     ;;Display
     bongo-mode-line-indicator-mode nil
     bongo-header-line-mode nil
     ;; Misc
     bongo-next-action 'bongo-play-next-or-stop
     bongo-display-playlist-after-enqueue nil
     bongo-seek-electric-mode t
     bongo-sprinkle-amount 50)
    (jr/bongo-mode-init)))
   #+end_src

** ag
   The [[https://github.com/ggreer/the_silver_searcher][silver searcher]] is an incredibly useful code-searching tool.
   Though it is similar to ack or grep, it is much, much faster. In order
   to use the ag.el package, make sure to install the binary for your
   operating system.
   #+begin_src emacs-lisp :tangle yes
(use-package ag
  :if (executable-find "ag")
  :defer t
  :config
  (progn
    (setq ag-highlight-search t
          ag-reuse-buffers t)
    (use-package wgrep-ag)))
   #+end_src
** wgrep
   #+begin_src emacs-lisp :tangle yes
(use-package wgrep
  :defer 10
  :config
  ;;This fixes an issue as discussed on
  ;;https://groups.google.com/forum/#!topic/gnu.emacs.help/uu6ZQZGQ9FA/discussion
  (setq grep-command "grep --color -nH -e "))
   #+end_src
** smartscan
   The [[https://github.com/mickeynp/smart-scan][smartscan]] package written by [[https://github.com/mickeynp/][Mickey Petersen]] allows you to jump
   between words or symbols under point. I found out about it from
   Mickey's [[http://sachachua.com/blog/2014/09/emacs-chat-mickey-petersen/][chat with Sasha Chua]].
   #+begin_src emacs-lisp :tangle yes
(use-package smartscan
  :config
  (global-smartscan-mode 1))
   #+end_src

** alert
   #+begin_src emacs-lisp :tangle yes
(use-package alert
  :config
  (setq alert-fade-time 4
        alert-default-style (if (executable-find "notify-send") 'libnotify 'message)
        alert-log-messages t))
   #+end_src

** pinentry
   The [[https://elpa.gnu.org/packages/pinentry.html][pinentry]] package allows GnuPG passphrase to be prompted through
   the minibuffer, which is convenient in tty mode or while connecting
   through ssh.
   #+begin_src emacs-lisp :tangle yes
(use-package pinentry
  :config
  (pinentry-start))
   #+end_src
** smart-mode-line
   #+begin_src emacs-lisp :tangle yes
(use-package smart-mode-line
  :config
  (progn
    (setq sml/no-confirm-load-theme t)
    (sml/setup)
    (setq sml/theme 'respectful
          sml/shorten-directory t
          sml/shorten-modes t
          sml/name-width 40
          sml/mode-width 'full)))
   #+end_src
** eval-sexp-fu
   #+begin_src emacs-lisp :tangle yes
(when (require 'eval-sexp-fu nil :no-error)
  (setq lisp-mode-hook nil)
  (add-hook 'lisp-mode-hook 'turn-on-eval-sexp-fu-flash-mode)
  (add-hook 'elpy-mode-hook 'turn-on-eval-sexp-fu-flash-mode))
   #+end_src
** CSV
   #+begin_src emacs-lisp :tangle yes
(use-package csv-mode
  :mode "\\.csv\\'")
   #+end_src
** Engine mode
   This is a useful mode that allows quick results from defined search
   engines.
   #+begin_src emacs-lisp :tangle yes
(use-package engine-mode
  :defer 10
  :config
  (progn
    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "d")
    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s"
      :keybinding "g")
    (defengine stack-overflow
      "https://stackoverflow.com/search?q=%s"
      :keybinding "s")
    (defengine wikipedia
      "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
      :keybinding "w"))
  (engine-mode t))
   #+end_src
** Savehist
   [[https://www.emacswiki.org/emacs/SaveHist][Savehist]] is the quick and dirty way to handle session management in
   emacs.
   #+begin_src emacs-lisp :tangle yes
(use-package savehist
  :ensure nil
  :custom
  (history-delete-duplicates t)
  (history-length t)
  (savehist-additional-variables
   '(kill-ring
     search-ring
     regexp-search-ring))
  (savehist-file (expand-file-name "history" user-emacs-directory))
  (savehist-save-minibuffer-history 1)
  :config (savehist-mode 1))
   #+end_src
** Autorevert
   Quick configuration for auto reverting files.
   #+begin_src emacs-lisp :tangle yes
(use-package autorevert
  :ensure nil
  :diminish auto-revert-mode
  :bind ("C-x R" . revert-buffer)
  :config
  (progn
    (global-auto-revert-mode 1)
    (setq global-auto-revert-non-file-buffers t
	  auto-revert-verbose t)))
   #+end_src
** Which-key
   Useful package that displays possible keybindings from the currently
   entered incomplete command.
   #+begin_src emacs-lisp :tangle yes
(use-package which-key
  :diminish
  :config
  (which-key-mode)
  (setq which-key-idle-delay 1)
  (setq which-key-max-description-length 30))
   #+end_src
** Lorem Ipsum
   #+begin_src emacs-lisp :tangle yes
(use-package lorem-ipsum
  :bind (("C-c C-v l" . lorem-ipsum-insert-list)
         ("C-c C-v p" . lorem-ipsum-insert-paragraphs)
         ("C-c C-v s" . lorem-ipsum-insert-sentences)))
   #+end_src

** LanguageTool
   [[http://www.languagetool.org/][LanguageTool]] is a spell and grammar checker written in Java.
   Configuration instructions can be found [[https://github.com/mhayashi1120/Emacs-langtool][here]].
   #+begin_src emacs-lisp :tangle yes
(use-package langtool
  :disabled t
  :diminish
  :custom
  (langtool-language-tool-jar "~/installs/LangueageTool-4.2/languagetool-commandline.jar")
  (langtool-language-tool-server-jar "~/installs/LanguageTool-4.2/languagetool-server.jar")
  :config
  (progn
    (setq langtool-server-user-arguments '("-p" "8082")
          langtool-default-language "en-US"
          langtool-mother-tongue "en"
          langtool-java-user-arguments '("-Dfile.encoding=UTF-8"))
    (global-set-key "\C-x4w" 'langtool-check)
    (global-set-key "\C-x4W" 'langtool-check-done)
    (global-set-key "\C-x4l" 'langtool-switch-default-language)
    (global-set-key "\C-x44" 'langtool-show-message-at-point)
    (global-set-key "\C-x4c" 'langtool-correct-buffer)))
   #+end_src
** Ledger
   Yet another awesome piece of work from John Wiegley
   (http://www.newartisans.com/). [[http://git.ledger-cli.org/][Ledger]] is the double-entry accounting
   system to rule them all.
   #+begin_src emacs-lisp :tangle yes
(use-package ledger-mode
  :mode "\\.ledger\\'"
  :config
  (progn
    (setq ledger-clear-whole-transactions t
          ledger-reconcile-default-commodity "USD"
          ledger-reconcile-default-date-format "%Y/%m/%d")
    (use-package flycheck-ledger
      :init
      (add-hook 'ledger-mode-hook #'flycheck-mode))))
   #+end_src
** Super Save
   [[https://github.com/bbatsov/super-save/][Super Save]] replaces the standard auto-save-mode.
   #+begin_src emacs-lisp :tangle yes
(use-package super-save
  :delight
  :config
  (progn
    (super-save-mode 1)
    (setq super-save-auto-save-when-idle t
          super-save-remote-files nil)
    (add-to-list 'super-save-triggers 'ace-window)
    (add-to-list 'super-save-hook-triggers 'counsel-find-file)))
   #+end_src

** EasyPG
   #+begin_src emacs-lisp :tangle yes
(require 'epg-config)
(add-to-list 'epg-config--program-alist
             `(OpenPGP epg-gpg-program
                       ("gpg" . ,epg-gpg-minimum-version)))
(setq epa-file-cache-passphrase-for-symmetric-encryption t
      epg--configurations nil)
   #+end_src

** Golden ratio
   A nice package that helps working with many windows is
   [[https://github.com/roman/golden-ratio.el][golden-ratio]], which resizes the current buffer to occupy an optimal
   part of the screen.
   #+begin_src emacs-lisp :tangle yes
(use-package golden-ratio
  :config
  (setq golden-ratio-auto-scale t))
   #+end_src
* Programming packages
** Generic
*** Dired
**** Dired-details
     [[https://www.emacswiki.org/emacs/DiredDetails][Dired-details]] lets you hide or show the file and directory details in
     a Dired listing, to save space and clutter
     #+begin_src emacs-lisp :tangle yes
(require 'dired-details)
(dired-details-install)
(setq dired-details-hidden-string "[...] ")
     #+end_src
     See [[http://emacsrocks.com/e16.html][Emacs Rocks! Episode 16]] to see the great use of dired-dwim-target
     #+begin_src emacs-lisp :tangle yes
(setq dired-dwim-target t)
     #+end_src
*** Flyspell
    First, we bootstrap [[http://aspell.net/][GNU Aspell]]
    #+begin_src emacs-lisp :tangle yes
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_US"
      flyspell-issue-message-flag nil
      ispell-list-command "--list") ; See https://www.emacswiki.org/emacs/FlySpell#tic5
    #+end_src

    Next, let's enable spell check for plain text and org-mode files when
    the aspell executable is present in the exec-path.
    #+begin_src emacs-lisp :tangle yes
(when (executable-find "aspell")
  (add-hook 'text-mode-hook 'flyspell-mode)
  (add-hook 'org-mode-hook  'flyspell-mode))
    #+end_src

*** Disable-mouse-mode
    [[https://github.com/purcell][Steve Purcell]] comes to the rescue to create a minor mode that disables
    mouse events
    #+begin_src emacs-lisp :tangle no
(use-package disable-mouse
  :delight disable-mouse-global-mode
  :config (global-disable-mouse-mode))
    #+end_src
*** Ediff
    [[https://www.gnu.org/software/emacs/manual/html_node/ediff/][Ediff]] allows simultaneous browsing through the differences between
    files or buffers. Very handy for comparing commits.
    #+begin_src emacs-lisp :tangle yes
(use-package ediff
  :ensure nil
  :init
  (defvar ctl-period-equals-map)
  (define-prefix-command 'ctl-period-equals-map)
  (bind-key "C-. =" #'ctl-period-equals-map)
  :bind (("C-. = b" . ediff-buffers)
         ("C-. = B" . ediff-buffers3)
         ("C-. = c" . compare-windows)
         ("C-. = =" . ediff-files)
         ("C-. = f" . ediff-files)
         ("C-. = F" . ediff-files3)
         ("C-. = r" . ediff-revision)
         ("C-. = p" . ediff-patch-file)
         ("C-. = P" . ediff-patch-buffer)
         ("C-. = l" . ediff-regions-linewise)
         ("C-. = w" . ediff-regions-wordwise))

  :config
  (setq ediff-diff-options "-w"
        ediff-split-window-function 'split-window-horizontally
        ediff-window-setup-function 'ediff-setup-windows-plain))
    #+end_src
*** Sexp highlighting
    [[https://www.emacswiki.org/emacs/ShowParenMode][show-paren-mode]] allows to see matching pairs of parentheses and other characters.
    #+begin_src emacs-lisp :tangle yes
(show-paren-mode 1)
(setq show-paren-style 'parenthesis)
    #+end_src
*** Utilities
    [[https://github.com/magnars/s.el][Magnar Sveen (magnars)'s String manipulation]] routines for emacs lisp
    #+begin_src emacs-lisp :tangle yes
(use-package s)
    #+end_src
*** Highlight
    #+begin_src emacs-lisp :tangle yes
(use-package highlight-symbol
  :diminish highlight-symbol-mode
  :commands highlight-symbol
  :bind ("C-x H" . highlight-symbol))

    #+end_src
*** Indentation
    I like to automatically indent when press RET
    #+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "RET") 'newline-and-indent)
(use-package aggressive-indent
  :defer 2
  :hook ((css-mode        . aggressive-indent-mode)
         (emacs-lisp-mode . aggressive-indent-mode)
         (js-mode         . aggressive-indent-mode)
         (lisp-mode       . aggressive-indent-mode))
  :custom (aggressive-indent-comments-too))
    #+end_src
*** Company
    [[http://company-mode.github.io/][Complete anything]] in emacs with company-mode.
    #+begin_src emacs-lisp :tangle yes
(use-package company
  :delight t
  :demand t
  :init
  (setq
   company-dabbrev-ignore-case nil
   company-dabbrev-code-ignore-case nil
   company-dabbrev-downcase nil
   company-idle-delay 1.0
   company-minimum-prefix-length 4)
  :bind (("C-c C-/" . company-complete)
         ("TAB" . company-complete))
  :config
  (progn
    (setq company-show-numbers t
          company-tooltip-align-annotations t
          company-idle-delay 1.0
          company-minimum-prefix-length 3)
    (global-company-mode 1)
    (use-package company-statistics
      :config
      (add-hook 'after-init-hook 'company-statistics-mode))
    (use-package company-box
      :disabled t
      :delight
      :hook (company-mode . company-box-mode)
      :config
      (progn
        (setq company-box-enable-icon t
              company-box-color-icon t
              company-box-max-candidates 50
              company-box-backends-colors
              '((company-yasnippet :all "lime green"
                                   :selected
                                   (:background "lime green" :foreground "black"))
                (company-elisp  :all "yellow"
                                :selected
                                (:background "orange" :foreground "black"))))))
    (define-key company-active-map [tab] nil)
    (define-key company-active-map (kbd "TAB") nil)))

    #+end_src
*** Code Folding
    The [[https://www.emacswiki.org/emacs/HideShow][hideshow]] minor mode allows one to hide and show blocks of text.
    #+begin_src emacs-lisp :tangle yes
(use-package hideshow
  :ensure nil
  :delight
  :defer t
  :config
  (progn
    ;; Hide the comments too when you do a 'hs-hide-all'
    (setq hs-hide-comments t)
    ;; Set whether isearch opens folded comments, code, or both
    ;; where x is code, comments, t (both), or nil (neither)
    (setq hs-isearch-open 't)
    (add-hook 'prog-mode-hook (lambda () (hs-minor-mode 1)))))
    #+end_src
*** Snippets
    The all great [[https://github.com/joaotavora/yasnippet][yasnippet]] package provides an extensible template system
    for Emacs. To get the actual snippets, we can use the great collection
    maintained by [[https://github.com/AndreaCrotti][AndreaCrotti]] named yasnippet-snippets.
    We also download [[https://github.com/mkcms/ivy-yasnippet][ivy-yasnippet]] by [[https://github.com/mkcms][mkcms]] to allow snippet previews through [[https://github.com/abo-abo/swiper][ivy]].
    #+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :demand t
  :delight yas-minor-mode
  :bind (("C-c y TAB" . yas-expand)
         ("C-c y s"   . yas-insert-snippet)
         ("C-c y n"   . yas-new-snippet)
         ("C-c y v"   . yas-visit-snippet-file))
  :config
  (progn
    (yas-global-mode 1)
    (use-package yasnippet-snippets)
    (use-package ivy-yasnippet
      :bind ("C-c y y" . ivy-yasnippet))))

    #+end_src

*** Completion
**** Ivy
     [[https://github.com/abo-abo/swiper][Ivy]] provides a completion mechanism for Emacs.
     It is my preferred completion method at the moment for its simplicity.
     Bundled, we find swiper and counsel which extend ivy.
     #+begin_src emacs-lisp :tangle yes
(use-package ivy
  :delight
  :demand t
  :bind
  ("C-x b" . ivy-switch-buffer)
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t
          ivy-height 10 ; number of result lines to display
          ivy-count-format "" ; does not count candidates
          ivy-initial-inputs-alist nil ; no regexp by default
          ivy-re-builders-alist ; configure regexp engine.
          '((t   . ivy--regex-ignore-order))) ; allow input not in order
    (use-package swiper)
    (use-package counsel
      :init
      (setq counsel-grep-swiper-limit 3000000)
      :bind
      (("C-h f" . counsel-describe-function)
       ("C-h l" . counsel-find-library)
       ("C-h v" . counsel-describe-variable)
       ("<f2> i" . counsel-info-lookup-symbol)
       ("<f2> u" . counsel-unicode-char)
       ("C-c j" . counsel-git-grep)
       ("C-c k" . counsel-ag)
       ("C-x C-f" . counsel-find-file)
       ("C-x C-r" . counsel-recentf)
       ;;("M-i" . counsel-imenu)
       ("C-c o" . counsel-linux-app)
       ("M-x" . counsel-M-x)
       ("M-y" . counsel-yank-pop)
       ("C-s" . counsel-grep-or-swiper)))))
     #+end_src
**** Ido mode
     [[https://www.emacswiki.org/emacs/InteractivelyDoThings][Interactively do things]] used to my completion framework at the
     beginning. I've now switched to [[https://github.com/abo-abo/swiper][Ivy]].
     #+begin_src emacs-lisp :tangle no
(use-package ido
  :disabled t                           ; I am using other completion instead
  :demand t
  :defines (ido-cur-item
            ido-require-match
            ido-selected
            ido-final-text
            ido-show-confirm-message)
  :bind (("C-x b" . ido-switch-buffer)
         ("C-x B" . ido-switch-buffer-other-window))
  :preface
  (eval-when-compile
    (defvar ido-require-match)
    (defvar ido-cur-item)
    (defvar ido-show-confirm-message)
    (defvar ido-selected)
    (defvar ido-final-text))
  :config
  (progn
    (ido-mode 'buffer)
    (ido-vertical-define-keys 'C-n-and-C-p-only)
    (add-hook 'ido-minibuffer-setup-hook
              #'(lambda ()
                  (bind-key "<return>" #'ido-smart-select-text
                            ido-file-completion-map)))))
     #+end_src

*** Version Control
    Version control is of incredibly importance for most projects and
    [[https://magit.vc][magit]] provides a great interface for [[https://git-scm.com/][git]]. [[https://github.com/magit/orgit][Orgit]] provides new [[https://orgmode.org/manual/External-links.html][org-link]]
    types for Magit buffers.

    #+begin_src emacs-lisp :tangle yes
(use-package magit
  :bind ("C-c g" . magit-status)
  :init
  (progn
    (add-hook 'magit-mode-hook 'hl-line-mode)
    (add-hook 'magit-log-mode-hook 'hl-line-mode))
  :config
  (progn
    (define-key magit-mode-map (kbd "C-<return>") nil)
    (use-package git-gutter
      :delight
      :config
      (global-git-gutter-mode +1))
    (use-package git-timemachine)))
    #+end_src
*** REST support
    See [[http://emacsrocks.com/e15.html][Emacs Rocks! Episode 15]] to learn how [[https://github.com/pashky/restclient.el][restclient]] can help out with
    testing APIs from within Emacs. The HTTP calls you make in the buffer
    aren't constrainted within Emacs; there’s the
    restclient-copy-curl-command to get the equivalent curl call string to
    keep things portable.
    #+begin_src emacs-lisp :tangle yes
(use-package restclient
  :mode ("\\.rest\\'" . restclient-mode))
    #+end_src
*** Multiple cursors
    See [[http://emacsrocks.com/e13.html][Emacs Rocks! Episode 13]] to learn about [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]], written
    by [[https://github.com/magnars/.emacs.d][Magnars Sveen]].
    #+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C-+"         . mc/mark-next-like-this)
         ("C-_"         . mc/mark-previous-like-this)
         ("C-c C-+"     . mc/mark-all-like-this)
         ("C-!"         . mc/mark-next-symbol-like-this)
         ("s-d"         . mc/mark-all-dwim)))
    #+end_src
*** Expand Region
    See [[http://emacsrocks.com/e09.html][Emacs Rocks! Episode 9]] to learn about [[https://github.com/magnars/.emacs.d][Magnars Sveen]]'s excellent
    expand-region.
    #+begin_src emacs-lisp :tangle yes
(use-package expand-region
  :defer 2
  :bind ("C-=" . er/expand-region))
    #+end_src
*** iy-go-to-char
    See [[http://emacsrocks.com/e04.html][Emacs Rocks! Episode 4]] to learn about [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]].
    #+begin_src emacs-lisp :tangle yes
(use-package iy-go-to-char
  :bind (("M-m" . iy-go-to-char)
         ("M-i" . back-to-indentation)))
    #+end_src
*** Autofill mode
    I find myself using M-q often to [[https://www.emacswiki.org/emacs/FillParagraph][refill paragraphs]]. [[https://www.emacswiki.org/emacs/AutoFillMode][AutoFillMode]] mostly
    automates this for me.
    #+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(global-set-key (kbd "C-c q") 'auto-fill-mode)
(setq comment-auto-fill-only-comments t)
    #+end_src
*** Nlinum
    Showing Line numbers in a buffer can be fairly useful when working
    with code. [[http://elpa.gnu.org/packages/nlinum.html][NLinum]] mode replaces the in-built linum-mode.
    #+begin_src emacs-lisp :tangle no
(use-package nlinum
  :init
  (defun my-nlinum-mode-hook ()
    (when nlinum-mode
      (setq-local nlinum-format
                  (concat "%" (number-to-string
                               ;; Guesstimate number of buffer lines.
                               (ceiling (log (max 1 (/ (buffer-size) 80)) 10)))
                          "d"))))
  :config
  (progn
    ;; Preset `nlinum-format' for minimum width. (from https://www.emacswiki.org/emacs/LineNumbers)  
    (add-hook 'prog-mode-hook 'nlinum-mode)
    (add-hook 'nlinum-mode-hook #'my-nlinum-mode-hook)))

    #+end_src

    #+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
    #+end_src
*** Whitespace-cleanup-mode
    [[https://github.com/purcell/whitespace-cleanup-mode][whitespace-cleanup-mode]] is a better solution than just having
    the whitespace-cleanup function running as part of the before-save-hook.
    #+begin_src emacs-lisp :tangle yes
(use-package whitespace-cleanup-mode
  :delight
  :config
  (global-whitespace-cleanup-mode 1))
    #+end_src
*** Smartparens
    #+begin_src emacs-lisp :tangle yes
(use-package smartparens
  :diminish t
  :init
  :config
  (progn
    (require 'smartparens-config)
    (sp-pair "(" ")" :wrap "s-(")
    (sp-pair "[" "]" :wrap "s-[")
    (sp-pair "{" "}" :wrap "s-{")
    (sp-local-pair 'prog-mode "{" nil :post-handlers '(("||\n[i]" "RET")))
    (add-hook 'smartparens-mode-hook #'show-smartparens-mode)
    (add-hook 'prog-mode-hook #'turn-on-smartparens-strict-mode)
    ;; The following is necessary per https://github.com/Fuco1/smartparens/issues/963
    (add-to-list 'sp--special-self-insert-commands 'c-electric-paren)
    (add-to-list 'sp--special-self-insert-commands 'c-electric-brace)
    (bind-keys
     :map smartparens-mode-map
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)

     ("C-<down>" . sp-down-sexp)
     ("C-<up>"   . sp-up-sexp)
     ("M-<down>" . sp-backward-down-sexp)
     ("M-<up>"   . sp-backward-up-sexp)

     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)

     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)

     ("C-S-f" . sp-forward-symbol)
     ("C-S-b" . sp-backward-symbol)

     ("C-<right>" . sp-forward-slurp-sexp)
     ("M-<right>" . sp-forward-barf-sexp)
     ("C-<left>"  . sp-backward-slurp-sexp)
     ("M-<left>"  . sp-backward-barf-sexp)

     ("C-M-t" . sp-transpose-sexp)
     ("C-M-k" . sp-kill-sexp)
     ("C-k"   . sp-kill-hybrid-sexp)
     ("M-k"   . sp-backward-kill-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("C-M-d" . delete-sexp)

     ("M-<backspace>" . backward-kill-word)
     ("C-<backspace>" . sp-backward-kill-word)
     ([remap sp-backward-kill-word] . backward-kill-word)

     ("M-[" . sp-backward-unwrap-sexp)
     ("M-]" . sp-unwrap-sexp)

     ("C-x C-t" . sp-transpose-hybrid-sexp))))
    #+end_src
*** projectile-mode
    The useful [[https://github.com/bbatsov/projectile][projectile-mode]] package by [[https://github.com/bbatsov/][bbastov]] provides lots of tools
    to interact with your project, which is defined as a simple folder
    with a special file such as .project, .projectile and many other
    supported types.
    #+begin_src emacs-lisp :tangle yes
(use-package projectile
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init   (setq projectile-use-git-grep t)
  :config
  (progn
    (setq projectile-cache-file "~/projectile.cache"
          projectile-completion-system 'ivy
          projectile-enable-caching t
          projectile-file-exists-local-cache-expire 120
          projectile-file-exists-remote-cache-expire 300
          projectile-known-projects-file "~/projectile-bookmarks.eld"
          projectile-sort-order 'recentf
          projectile-track-known-projects-automatically t)
    (add-to-list 'projectile-other-file-alist '("clj" "cljs"))
    (add-to-list 'projectile-other-file-alist '("cljs" "clj"))
    (global-set-key (kbd "M-.") 'projectile-find-tag)
    (global-set-key (kbd "M-,") 'pop-tag-mark)
    (when (window-system)
      (setq projectile-mode-line '(:eval (format " Π[%s]" (projectile-project-name)))))
    (use-package counsel-projectile
      :config
      (progn
        (counsel-projectile-mode 1)))))
    #+end_src
*** Flycheck
    Per the [[http://www.flycheck.org/en/latest/][flycheck website]], Flycheck is a modern on-the-fly syntax
    checking extension for GNU Emacs, intended as replacement for the
    older Flymake extension which is part of GNU Emacs.
    #+begin_src emacs-lisp :tangle yes
(use-package flycheck)

(use-package flycheck-color-mode-line
  :after flycheck
  :commands flycheck-color-mode-line-mode
  mess  :hook (flycheck-mode . flycheck-color-mode-line-mode))
    #+end_src
*** GGTags
    #+begin_src emacs-lisp :tangle false
;; GNU Global Tags
(use-package ggtags
  :commands ggtags-mode
  :diminish ggtags-mode
  :bind (("M-," . pop-tag-mark)
         ("M-." . ggtags-find-tag-dwim)
         ("C-c t s" . ggtags-find-other-symbol)
         ("C-c t h" . ggtags-view-tag-history)
         ("C-c t r" . ggtags-find-reference)
         ("C-c t f" . ggtags-find-file)
         ("C-c t c" . ggtags-create-tags))
  :init
  (add-hook 'c-mode-common-hook
            #'(lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                  (ggtags-mode 1))))
  :config
  (progn
    (add-hook 'c-mode-common-hook
              (lambda ()
                (ggtags-mode 1)
                (add-to-list 'c-default-style '(c++ . "stroustrup"))
                (smartparens-strict-mode 1)
                (define-key c++-mode-map (kbd "<f5>") (lambda ()
                                                        (interactive)
                                                        (setq-local compilation-read-command nil)
                                                        (call-interactively 'compile)))
                (sp-with-modes '(c-mode c++-mode java-mode)
                  (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
                  ;; (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                  ;;                                           ("* ||\n[i]" "RET")))
                  )))))
    #+end_src

** Language Specific
*** Eshell
    [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]] is a shell-like command interpreter implemented in Emacs Lisp and written
    by the great [[https://www.google.com/search?q=eshell+jwiegleyt&ie=utf-8&oe=utf-8][John Wiegley]].
    #+begin_src emacs-lisp :tangle yes
(use-package eshell
  :ensure nil
  :bind ("C-x t" . eshell)
  :config
  (progn
    (defalias 'open 'find-file)
    (defalias 'openo 'find-file-other-window)
    (add-hook 'eshell-mode-hook (lambda ()
                                  (company-mode -1)
                                  (display-line-numbers-mode -1)))))
    #+end_src

*** Clojure
    [[https://www.google.com/search?q=clojure&ie=utf-8&oe=utf-8][Clojure]] is a dynamic programming language that compiles to Java
    Unicode. It's one of my main languages right now.
    #+begin_src emacs-lisp :tangle yes
(use-package clojure-mode
  :mode "\\.cljs?\\'"
  :config
  (progn
    (use-package cider)
    (setq cider-cljs-lein-repl
          "(do (require 'figwheel-sidecar.repl-api)
           (figwheel-sidecar.repl-api/start-figwheel!)
           (figwheel-sidecar.repl-api/cljs-repl))"

          org-babel-clojure-backend 'cider
          cider-inject-dependencies-at-jack-in nil)
    (require 'ob-clojure)
    (define-key cider-repl-mode-map (kbd "C-<return>") 'other-window)
    (add-hook 'before-save-hook (lambda ()
                                  (when (or (eq major-mode 'clojure-mode)
                                            (eq major-mode 'lisp-mode))
                                    (whitespace-cleanup)
                                    (indent-region (point-min) (point-max)))))))
    #+end_src
*** Common Lisp
    [[https://common-lisp.net/][Common Lisp]], the programmable programming language.
    The following sets up [[https://www.emacswiki.org/emacs/SlimeMode][slime]] to use [[http://www.sbcl.org/][SBCL]] so ensure you have SBCL
    installed first.
    #+begin_src emacs-lisp :tangle no
(use-package slime
  :disabled t
  :init
  (progn
    (cond
     ((file-exists-p "/usr/bin/sbcl")
      (setq inferior-lisp-program "/usr/bin/sbcl"))
     ((file-exists-p "/opt/local/bin/sbcl")
      (setq inferior-lisp-program "/opt/local/bin/sbcl")))
    (when (file-exists-p "/home/jeko/build/slime")
      (add-to-list 'load-path "/home/jeko/build/slime"))
    (setq inferior-lisp-program "sbcl")
    (require 'slime-autoloads)
    (add-to-list 'slime-contribs 'slime-fancy)
    (when (file-exists-p "~/quicklisp/slime-helper.el")
      (load (expand-file-name "~/quicklisp/slime-helper.el")))
    (add-to-list 'slime-contribs 'slime-repl))
  :config
  (progn
    (when (file-exists-p "/home/jeko/build/sbcl.core-for-slime")
      (setq slime-lisp-implementations
            '((sbcl ("sbcl" "--core" "/home/jeko/build/sbcl.core-for-slime")))))    
    (setq slime-net-coding-system 'utf-8-unix)
    (add-hook 'slime-mode-hook
              (lambda ()
                (cond ((boundp 'slime-mode-map)
                       (define-key slime-mode-map (kbd "C-c x") nil)
                       (message "slime keybinding on C-c x has been sanitized"))
                      ('t (message "slime keybindings not sanitized")))))
    (use-package slime-company
      :config
      (add-to-list 'slime-contribs 'slime-company))

    (add-to-list 'company-backends '(company-slime :with company-dabbrev))
    (use-package common-lisp-snippets
      :defer t)))
    #+end_src
    #+begin_src emacs-lisp :tangle yes
;; sly
(use-package sly
  :init
  (progn
    (when (file-exists-p "/home/jeko/build/sly")
      (add-to-list 'load-path "/home/jeko/build/sly")
      (require 'sly-autoloads))
    (setq inferior-lisp-program "sbcl"))
  :config
  (progn
    (defun jr/sly-hook ()
      (sly-mode +1)
      (sly-autodoc-mode +1))
    (add-hook 'lisp-mode-hook 'jr/sly-hook)
    (setq sly-complete-symbol-function 'sly-flex-completions)))

(use-package common-lisp-snippets
  :after sly)
    #+end_src
*** Scheme
    [[https://en.wikipedia.org/wiki/Scheme_%2528programming_language%2529][Scheme]] is a dialect of Lisp developed by Gerald Sussman and Guy
    Steele.
    [[https://github.com/jaor/geiser][Geiser]] provides an improved development environment in emacs.
    #+begin_src emacs-lisp :tangle yes
(use-package geiser
  :defer t
  :config
  (progn
    (setq geiser-active-implementations '(mit)
          geiser-mit-binary "/usr/bin/mit-scheme")
    (setq scheme-program-name "/usr/bin/mit-scheme")))
    #+end_src
*** Emacs Lisp
    #+begin_src emacs-lisp :tangle yes
(defun eval-and-replace ()
  "Replace the preceding sexp with its value.
    Source: http://emacsredux.com/blog/2013/06/21/eval-and-replace/"
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun jr/noisy-eval-buffer ()
  "Evaluate the current buffer and print a simple message"
  (interactive)
  (eval-buffer)
  (message "Visible section in buffer %s has been evaluated." (buffer-name)))

(define-key lisp-mode-map (kbd "C-c e b") 'jr/noisy-eval-buffer)
(define-key lisp-mode-map (kbd "C-c e d") 'toggle-debug-on-error)
(define-key lisp-mode-map (kbd "C-c e c") 'emacs-lisp-byte-compile-and-load)
(define-key lisp-mode-map (kbd "C-c e r") 'eval-region)
(define-key lisp-mode-map (kbd "C-c e e") 'eval-and-replace)

(define-key lisp-interaction-mode-map (kbd "C-c e b") 'jr/noisy-eval-buffer)
(define-key lisp-interaction-mode-map (kbd "C-c e d") 'toggle-debug-on-error)
(define-key lisp-interaction-mode-map (kbd "C-c e c") 'emacs-lisp-byte-compile-and-load)
(define-key lisp-interaction-mode-map (kbd "C-c e r") 'eval-region)
(define-key lisp-interaction-mode-map (kbd "C-c e e") 'eval-and-replace)

;; Let's add a couple of bindings to C-c C-z to be able to switch back
;; and forth between an emacs-lisp buffer and ielm
(defcustom jr/ielm-repl-display-in-current-window nil
  "When non-nil, show the ielm REPL buffer in the current window."
  :type 'boolean
  :group 'ielm)

(defun jr/ielm-switch-to-ielm-buffer ()
  "Switch to the ielm buffer in an existing window, when
  possible. If `jr/ielm-repl-display-in-current-window' is non-nil,
  then attempt to use the same window."
  (interactive)
  (let ((ielm-buff-name "*ielm*"))
    (unless (comint-check-proc ielm-buff-name)
      (with-current-buffer (get-buffer-create ielm-buff-name)
        (inferior-emacs-lisp-mode)))
    (if jr/ielm-repl-display-in-current-window
        (pop-to-buffer-same-window ielm-buff-name)
      (pop-to-buffer ielm-buff-name))))

(define-key emacs-lisp-mode-map (kbd "C-c C-z") 'jr/ielm-switch-to-ielm-buffer)

(defun jr/ielm-switch-to-last-emacs-lisp-buffer ()
  "Switch to the last emacs-lisp buffer in an existing window,
  when possible. If `jr/ielm-repl-display-in-current-window' is
  non-nil, then attempt to use the same window."
  (interactive)
  (when (eq major-mode 'inferior-emacs-lisp-mode)
    (let ((last-buff (seq-find (lambda (b)
                                 (with-current-buffer b
                                   (eq major-mode 'emacs-lisp-mode)))
                               (buffer-list))))
      (when last-buff
        (if jr/ielm-repl-display-in-current-window
            (pop-to-buffer-same-window last-buff)
          (pop-to-buffer last-buff))))))

(use-package ielm
  :disabled t
  :config
  (progn
    (define-key ielm-map (kbd "C-c C-z") 'jr/ielm-switch-to-last-emacs-lisp-buffer)))

(bind-key "RET" 'comment-indent-new-line emacs-lisp-mode-map)

(use-package eldoc
  :ensure nil
  :diminish eldoc-mode
  :commands eldoc-mode)

    #+end_src
*** Markdown
    I like to edit README and other files written in Markdown so having
    [[https://jblevins.org/projects/markdown-mode/][markdown-mode]] is very convenient.
    #+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :mode "\\.md\\'")
    #+end_src
*** TeX/LaTeX
    #+begin_src emacs-lisp :tangle yes
(use-package tex
  :ensure auctex
  :mode ("\\.tex\\'" . TeX-latex-mode)
  :config
  (progn
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-byte-compile t
          TeX-master 'dwim
          TeX-view-program-selection '((output-pdf "Evince")
                                       (output-html "xdg-open"))
          TeX-engine 'xetex)
    (TeX-source-correlate-mode 1)
    (use-package company-auctex
      :config (company-auctex-init))))
    #+end_src

*** Web editing
    The [[http://web-mode.org/][web-mode]] is particularily good for editing HTML templates. It
    natively understands embedded CSS and JavaScript code blocks.

    We also install [[https://github.com/emacsmirror/rainbow-mode][rainbow-mode]] to colorize color names in web and CSS buffers.
    #+begin_src emacs-lisp :tangle no
(use-package web-mode
  :mode (("\\.html?\\'" . web-mode)
         ("\\.jsx?\\'" . web-mode)
         ("\\.mustache\\'" . web-mode)
         ("\\.xhtml?\\'" . web-mode)
         ("\\.xml\\'" . web-mode))
  :config
  (progn
    (use-package prettier-js)
    (use-package add-node-modules-path
      :config
      (progn
        (defun jr/web-mode-init-prettier-hook ()
          (add-node-modules-path)
          (prettier-js-mode))
        (add-hook 'web-mode-hook 'jr/web-mode-init-prettier-hook)))
    (defun jr/web-mode-hook ()
      (when (boundp 'flycheck-disabled-checkers)
        (add-to-list 'flycheck-disabled-checkers 'javascript-jshint)
        (add-to-list 'flycheck-disabled-checkers 'json-jsonlist)
        (flycheck-add-mode 'javascript-eslint 'web-mode)
        (smartparens-global-strict-mode +1)
        (flycheck-mode +1)))
    (add-hook 'web-mode-hook #'jr/web-mode-hook)
    (setq web-mode-engines-alist
          '(("django"    . "\\.html\\'")
            ("jinja2"    . "\\.html\\'")
            ("php"       . "\\.phtml\\'"))
          web-mode-content-types-alist
          '(("jsx" . "\\.js[x]?\\'"))
          web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-indent-style 2
          web-mode-style-padding 1
          web-mode-script-padding 1
          web-mode-block-padding 0
          web-mode-enable-auto-closing t
          web-mode-enable-auto-closing t
          web-mode-enable-auto-quoting t
          web-mode-enable-auto-pairing t
          web-mode-enable-css-colorization t
          web-mode-enable-engine-detection t)
    (use-package rainbow-mode
      :hook (web-mode css-mode)
      :defer t
      :config
      (progn
        (add-hook 'web-mode-hook #'rainbow-mode)
        (add-hook 'css-mode-hook #'rainbow-mode)))
    (use-package emmet-mode)
    (use-package company-web
      :config
      (define-key web-mode-map (kbd "C-'") 'company-web-html))))
    #+end_src

    [[https://github.com/skeeto/impatient-mode][Impatient mode]] allows one to see changes to HTML buffers _instantly_
    as you type which is very cool. There's even this [[http://youtu.be/QV6XVyXjBO8][YouTube video]] that
    shows what it does.

    Oh, and remember that [[https://github.com/rg3/youtube-dl][youtube-dl]] is a great way to download/watch
    YouTube videos!
    #+begin_src emacs-lisp :tangle yes
(use-package simple-httpd
  :defer t
  :config
  (progn
    (setq httpd-root "/var/www/html")
    (use-package impatient-mode
      :hook ((web-mode . httpd-start)
             (web-mode . impatient-mode)
             (css-mode . httpd-start)))))
    #+end_src
*** Java/JDEE
    And, of course, Java. The programming language that many people love to hate.
    #+begin_src emacs-lisp :tangle yes
(use-package lsp-java
  :requires lsp
  :init
  (defun jr/lsp-java-config ()
    (setq c-default-style "java")
    (setq-local tab-width 4
                c-basic-offset 4)
    (c-set-offset 'arglist-intro '+)
    (c-set-offset 'arglist-close '0)
    (c-set-offset 'case-label '+)
    (lsp))
  :hook (java-mode . jr/lsp-java-config)
  :config
  (setq lsp-file-watch-ignored
        '(".idea" ".ensime_cache" ".eunit" "node_modules"
          ".git" ".hg" ".fslckout" "_FOSSIL_"
          ".bzr" "_darcs" ".tox" ".svn" ".stack-work"
          "build")
        lsp-java-import-order '["" "java" "javax" "#"]))

(use-package java-snippets
  :after yasnippet
  :config
  (java-snippets-initialize))
    #+end_src
    #+begin_src emacs-lisp :tangle no
(use-package jdee
  :disabled t
  :defer t
  :config
  (progn
    (setq jdee-server-dir (concat user-emacs-directory "jars")
          jdee-jdk-registry '(("1.8" . "/usr/lib/jvm/java-8-openjdk")
                              ("1.8" . "/usr/lib64/jvm/java-8-openjdk"))
          jdee-jdk '("1.8")
          jdee-enable-abbrev-mode t
          jdee-gen-k&r t
          tempo-interactive nil
          jdee-gen-cflow-enable nil ;; We'll use yasnippets instead
          jdee-complete-function 'jdee-complete-minibuf
          jdee-compiler '("javac");;("javac server")
          jdee-electric-return-p nil
          jdee-global-classpath '("." "./lib")
          jdee-import-sorted-groups t
          jdee-build-function  'jdee-ant-build
          jdee-project-file-name "prj.el"
          jdee-jdk-doc-url "https://docs.oracle.com/javase/8/docs/api/overview-summary.html"
          jdee-sourcepath "/usr/lib/jvm/java-8-openjdk/jre/lib")
    (defun jr/compile-and-run ()
      (interactive)
      (jdee-compile)
      (jdee-run 1))
    (define-key jdee-mode-map [f5] 'jr/compile-and-run)

    (defun jr/company-jdee-backend (command &optional arg &rest ignored)
      (interactive (list 'interactive))
      (pcase command
        (`interactive
         (company-begin-backend 'jr/company-jdee-backend))

        (`prefix
         (when (and (eq major-mode 'jdee-mode)
                    (not (company-in-string-or-comment)))
           (let ((pair (jdee-parse-java-variable-at-point)))
             (if (not (s-blank-str? (car pair)))
                 (s-join "|" pair)
               nil))))
        (`candidates
         (if arg
             (let ((pair (s-split "|" arg)))
               (seq-map (lambda (p) (concat (car pair) "." (cdr p))) (jdee-complete-find-completion-for-pair pair)))))))
    (add-to-list 'company-backends 'jr/company-jdee-backend)))
    #+end_src
**** Gradle
     #+begin_src emacs-lisp :tangle yes
(use-package gradle-mode
  :delight gradle-mode "γ"
  :mode "\\.gradle\\'"
  :interpreter ("gradle" . gradle-mode)
  :config
  (add-hook 'java-mode-hook '(lambda() (gradle-mode 1))))
     #+end_src
**** Eclim
     From the [[https://github.com/emacs-eclim/emacs-eclim#user-content-overview][emacs-eclim readme]]:

     Eclim is an Eclipse plugin which exposes Eclipse features through a
     server interface. When this server is started, the command line
     utility eclim can be used to issue requests to that server.
     #+begin_src emacs-lisp :tangle yes
(use-package eclim
  :disabled t
  :config
  (progn
    ;; Eclim settings
    (setq eclim-accepted-file-regexps
          '("\\.java$" "\\.xml$" "\\.h$")
          eclim-use-yasnippet t
          help-at-pt-display-when-idle t
          help-at-pt-timer-delay 0.5)
    (help-at-pt-set-timer)
    (define-key eclim-mode-map (kbd "C-c C-e C-c") 'eclim-problems-correct)
    (require 'eclimd)
    (setq eclimd-autostart t
          eclimd-default-workspace "/data/rep/personal/prog/java/EclimProjects"
          eclim-print-debug-messages t)
    (add-hook 'java-mode-hook 'eclim-mode)
    (define-key java-mode-map (kbd "C-c C-c") 'compile)
    (use-package company-emacs-eclim
      :config
      (company-emacs-eclim-setup))))
     #+end_src
**** Meghanada
     #+begin_src emacs-lisp :tangle no
(use-package meghanada
  :init
  (defun jr/meghanada-java-mode-hook ()
    (meghanada-mode t)
    (flycheck-mode +1)
    (setq c-basic-offset 2)
    (add-hook 'before-save-hook 'meghanada-code-beautify-before-save))
  :hook (java-mode . jr/meghanada-java-mode-hook)
  :config
  (progn
    (when (package-installed-p 'ggtags)
      (define-key meghanada-mode-map (kbd "M-.") #'ggtags-find-tag-dwim)
      (define-key meghanada-mode-map (kbd "M-,") #'pop-tag-mark))
    (cond
     ((eq system-type 'windows-nt)
      (setq meghanada-java-path (expand-file-name "bin/java.exe" (getenv "JAVA_HOME")))
      (setq meghanada-maven-path "mvn.cmd"))
     (t
      (setq meghanada-java-path "java")
      (setq meghanada-maven-path "mvn")))))
     #+end_src
*** Python
    #+begin_src emacs-lisp :tangle yes
(use-package elpy
  :delight python-mode "π"
  :disabled t
  :config
  (progn
    (elpy-enable)

    ;; elpy
    (add-hook 'elpy-mode-hook 'smartparens-strict-mode)
    (add-hook 'inferior-python-mode-hook 'smartparens-strict-mode)

    ;;config
    (defalias 'workon 'pyvenv-workon)

    ;; documentation
    (add-to-list 'elpy-modules 'elpy-module-autodoc)
    (setq elpy-autodoc-delay 0.5)

    ;; interpreter
    (if (executable-find "ipython")
        (setq python-shell-interpreter "ipython"
              python-shell-interpreter-args "-i --simple-prompt")
      (setq python-shell-interpreter "python"
            python-shell-interpreter-args "-i"))

    ;; Shell Buffer
    (setq elpy-shell-use-project-root t
          elpy-shell-echo-input t
          elpy-shell-echo-input-cont-prompt t
          elpy-shell-echo-input-lines-head 5
          elpy-shell-echo-input-lines-tail 5
          elpy-shell-echo-output 'when-shell-not-visible)

    ;; Syntax checking
    (setq python-check-command
          (or (executable-find "flake8")
              (executable-find "pylint")))

    (when (and (package-installed-p 'flycheck)
               python-check-command)
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode)
      (define-key elpy-mode-map (kbd "C-c C-n") 'flycheck-next-error)
      (define-key elpy-mode-map (kbd "C-c C-p") 'flycheck-previous-error))

    (add-hook 'elpy-mode-hook
              (lambda ()
                (add-hook 'before-save-hook 'elpy-format-code nil t)))
    (use-package pydoc-info)))
    #+end_src

*** SQL
    #+begin_src emacs-lisp :tangle yes
(use-package sql
  :disabled t
  :mode "\\.sql\\'"
  :config
  (progn
    (use-package sqlup-mode)
    (use-package sql-indent)
    (defun jr/sql-modes-hook ()
      (sqlup-mode 1)
      (sqlind-minor-mode 1)
      (smartparens-strict-mode))

    (add-hook 'sql-mode-hook 'jr/sql-modes-hook)
    (add-hook 'sql-interactive-mode-hook 'jr/sql-modes-hook)
    (add-to-list 'sqlup-blacklist "user")))
    #+end_src
*** JavaScript
    #+begin_src emacs-lisp :tangle yes
(use-package js
  :ensure nil
  :after (flycheck smartparens)
  :init
  :config
  (progn
    (when (executable-find "eslint")
      (setq-default flycheck-disabled-checkers
                    (append flycheck-disabled-checkers
                            '(javascript-jshint)))
      (add-hook 'js-mode-hook #'flycheck-mode))
    (sp-with-modes '(js-mode)
      (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
      (sp-local-pair "[" nil :post-handlers '(("||\n[i]" "RET")))
      (sp-local-pair "(" nil :post-handlers '(("||\n[i]" "RET"))))
    ;; use local eslint from node_modules before global
    ;; http://emacs.stackexchange.com/questions/21205/flycheck-with-file-relative-eslint-executable
    (defun jr/use-eslint-from-node-modules ()
      (let* ((root (locate-dominating-file
                    (or (buffer-file-name) default-directory)
                    "node_modules"))
             (eslint (and root
                          (expand-file-name "node_modules/eslint/bin/eslint.js"
                                            root))))
        (when (and eslint (file-executable-p eslint))
          (setq-local flycheck-javascript-eslint-executable eslint))))
    (add-hook 'flycheck-mode-hook #'jr/use-eslint-from-node-modules)
    (let ((indent-level 2))
      (setq js-chain-indent t
            js-indent-level indent-level
            js-jsx-attribute-offset indent-level
            js-jsx-detect-syntax t
            js-jsx-align->-with-< t
            js-jsx-indent-level indent-level))))

(use-package tide
  :after (company flycheck)
  :init
  (defun jr/tide-mode-hook ()
    (interactive)
    (tide-setup)
    (flycheck-mode)
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    (company-mode +1))
  :hook (js-mode . jr/tide-mode-hook)
  :config
  ;; configure javascript-tide checker to run after your default javascript checker
  ;;(flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append)
  )
    #+end_src
    #+begin_src emacs-lisp :tangle no
(use-package js2-mode
  :mode ("\\.js\\'")
  :config
  (progn
    (use-package js2-refactor
      :config
      (progn
        (add-hook 'js2-mode-hook #'js2-refactor-mode)
        (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
        (js2r-add-keybindings-with-prefix "C-c C-m")
        (setq js2-skip-preprocessor-directives t)
        (use-package xref-js2
          :config
          (progn
            (add-hook 'js2-mode-hook
                      (lambda ()
                        (add-hook 'xref-backend-functions
                                  #'xref-js2-xref-backend nil t)))
            ;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
            ;; unbind it.
            (define-key js-mode-map (kbd "M-.") nil)))
        (when (executable-find "tern")
          (use-package company-tern
            :config
            (progn
              (add-to-list 'company-backends 'company-tern)
              (add-hook 'js2-mode-hook (lambda ()
                                         (tern-mode)))
              ;; Disable completion keybindings, as we use xref-js2 instead
              (define-key tern-mode-keymap (kbd "M-.") nil)
              (define-key tern-mode-keymap (kbd "M-,") nil))))))
    (use-package indium
      :demand t
      :bind (("C-c C-v r" . indium-eval-region)
             ("C-c C-v b" . indium-eval-buffer))
      :config
      (progn
        (add-hook 'js2-mode-hook
                  (lambda ()
                    (smartparens-strict-mode 1)
                    (indium-interaction-mode)))
        (add-to-list 'company-backends #'company-indium-repl)))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes

    #+end_src

*** Move-text
    #+begin_src emacs-lisp :tangle yes
(use-package move-text
  :disabled t
  :defer 2
  :bind (("M-p" . move-text-up)
         ("M-n" . move-text-down))
  :config (move-text-default-bindings))
    #+end_src
*** Multi-term
    #+begin_src emacs-lisp :tangle yes
(use-package multi-term
  :bind (("C-x T T" . multi-term)
         ("C-c C-n" . multi-term-next)
         ("C-c C-p" . multi-term-prev))
  :init
  (defun jr/term-mode-hook ()
    (copy-face 'default 'term-face)
    (yas-minor-mode -1)
    (auto-fill-mode -1)
    (compilation-shell-minor-mode t))
  :config
  (progn
    (setq multi-term-program "/bin/bash"
          multi-term-buffer-name "term"
          term-unbind-key-list '("C-x"
                                 "C-h"
                                 "M-x"
                                 "C-z")
          multi-term-scroll-to-bottom-on-output t)
    (cl-flet ((set-color (pair)
                         (multiple-value-bind (face color)
                             pair
                           (set-face-attribute face
                                               nil
                                               :foreground color
                                               :background nil))))
      (mapc #'set-color
            '((term-color-black "#2e3434")
              (term-color-red "tomato")
              (term-color-green "#6ac214")
              (term-color-yellow "#edd400")
              (term-color-blue "light sky blue")
              (term-color-magenta "magenta")
              (term-color-cyan "cyan")
              (term-color-white "#eeeeec"))))
    (setq-default ansi-term-color-vector
                  [term-face
                   term-color-black
                   term-color-red
                   term-color-green
                   term-color-yellow
                   term-color-blue
                   term-color-magenta
                   term-color-cyan
                   term-color-white])
    (add-hook 'term-mode-hook 'jr/term-mode-hook)
    (define-key term-raw-map (kbd "C-c C-n") 'multi-term-next)
    (define-key term-raw-map (kbd "C-c C-p") 'multi-term-prev)))
    #+end_src
*** C++
    #+begin_src emacs-lisp :tangle yes
(use-package irony
  :init
  (add-hook 'c++-mode-hook 'irony-mode)
  :config
  (defun jr/irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async)
    (setq company-backends (delete 'company-semantic company-backends))
    (setq-local eldoc-documentation-function #'ggtags-eldoc-function))
  (add-hook 'irony-mode-hook 'jr/irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

(use-package company-c-headers
  :config
  (progn
    (add-to-list 'company-c-headers-path-system "/usr/include/c++/8.2.1/")
    (add-to-list 'company-backends 'company-c-headers)))
    #+end_src

*** Octave
    [[https://www.gnu.org/software/octave/][GNU Octave]] is a powerful programming language for scientific
    computing. Its syntax is largely compatible with Matlab alongside a
    few improvements.
    #+begin_src emacs-lisp :tangle yes
(use-package octave
  :ensure nil
  :mode "\\.m\\'"
  :config
  (progn
    (setq inferior-octave-startup-args '("-i" "--no-line-editing" "-q" "--braindead" "--no-gui"))
    (add-hook 'inferior-octave-mode-hook
              (lambda ()
                (define-key inferior-octave-mode-map [up]
                  'comint-previous-input)
                (define-key inferior-octave-mode-map [down]
                  'comint-next-input)))))
    #+end_src
*** Scala
    #+begin_src emacs-lisp :tangle yes
(use-package ensime
  :defer t
  :pin melpa-stable
  :config
  (progn
    (let ((sbt "/usr/bin/sbt"))
      (when (file-exists-p sbt)
        (setq ensure-sbt-command sbt
              sbt:program-name sbt)))
    (setq ensime-eldoc-hints 'all
          ensime-search-interface 'ivy
          ensime-sbt-perform-on-save t
          ensime-startup-notification nil
          ensime-typecheck-idle-interval 1
          ensime-typecheck-interval 2
          ensime-company-idle-delay 1)
    (bind-key "s-<delete>" (sp-restrict-c 'sp-kill-sexp) scala-mode-map)
    (bind-key "s-<backspace>" (sp-restrict-c 'sp-backward-kill-sexp) scala-mode-map)
    (bind-key "s-<home>" (sp-restrict-c 'sp-beginning-of-sexp) scala-mode-map)
    (bind-key "s-<end>" (sp-restrict-c 'sp-end-of-sexp) scala-mode-map)
    (bind-key "C-<tab>" 'dabbrev-expand scala-mode-map)
    (require 'ensime-expand-region)))

(use-package sbt-mode
  :commands sbt-start sbt-command
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map)
  (add-hook 'sbt-mode-hook
            (lambda ()
              (setq prettify-symbols-alist
                    `((,(expand-file-name (directory-file-name default-directory)) . ?⌂)
                      (,(expand-file-name "~") . ?~)))
              (prettify-symbols-mode t))))

(use-package scala-mode
  :interpreter
  ("scala" . scala-mode)
  :mode ((".ensime" . scala-mode)
         ("\\.scala\\'" . scala-mode))
  :config
  (setq scala-indent:use-javadoc-style nil
        scala-indent:add-space-for-scaladoc-asterisk t
        scala-indent:default-run-on-strategy 2
        scala-indent:indent-value-expression nil
        scala-indent:align-parameters nil
        scala-indent:align-forms nil)
  (defun scala-mode-newline-comments ()
    "Custom newline appropriate for `scala-mode'."
    ;; shouldn't this be in a post-insert hook?
    (interactive)
    (newline-and-indent)
    (scala-indent:insert-asterisk-on-multiline-comment))
  (bind-key "RET" 'scala-mode-newline-comments scala-mode-map)
  (add-hook 'scala-mode-hook (lambda ()
                               (setq prettify-symbols-alist scala-prettify-symbols-alist
                                     comment-start "/* "
                                     comment-end " */"
                                     comment-style 'multi-line
                                     comment-empty-lines t
                                     fill-column 100)
                               (show-paren-mode +1)
                               (setq company-backends '((ensime-company company-dabbrev-code company-capf company-semantic)))
                               (yas-minor-mode +1)
                               (ensime-mode +1)
                               (prettify-symbols-mode)
                               (smartparens-strict-mode +1)
                               (scala-mode:goto-start-of-code))))
    #+end_src
* Gnus
  [[https://www.emacswiki.org/emacs/GnusTutorial][Gnus]] is my preferred e-mail reader.
  It takes a while to get it used to it all (similar to emacs
  actually) but it more than pays off at the end. Here's [[http://www.gnus.org/manual.html][the manual]].
  #+begin_src emacs-lisp :tangle yes
;; (let ((gnus-config-file (expand-file-name "settings/gnus-init.el" user-emacs-directory)))
;;   (when (file-exists-p gnus-config-file)
;;     (setq gnus-init-file gnus-config-file)))
(setq jr/gnus-config-file (expand-file-name "site-lisp/dot-gnus/dot-gnus.org" user-emacs-directory))

(when (file-exists-p jr/gnus-config-file)
  (setq gnus-init-file (car (org-babel-tangle-file jr/gnus-config-file))))
  #+end_src

  Let's set gnus as our mail handler
  #+begin_src emacs-lisp :tangle yes
(setq mail-user-agent 'gnus-user-agent)
  #+end_src

  In the rare occasion that I create a new mail via C-x m and gnus
  isn't open, I want to start gnus up first:
  #+begin_src emacs-lisp :tangle yes
(defun jr/start-gnus-maybe (&rest args)
  "Start gnus if it isn't currently running."
  (unless (gnus-alive-p)
    (message "Starting Gnus...")
    (save-excursion
      (let ((inhibit-redisplay t))
        (gnus)))))

(advice-add 'compose-mail :before #'jr/start-gnus-maybe)
  #+end_src

  #+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x g") 'gnus)
  #+end_src

* Org Mode
  When all else fails, [[https://orgmode.org/][org mode]] will work. I use it for almost
  everything, including, of course, writing this document.
  Here's [[https://orgmode.org/manual/][the manual]].

  I have moved my entire org-mode configuration to its own repository
  under https://github.com/jeko2000/dot-org.
  #+begin_src emacs-lisp :tangle yes
(let ((org-config-file (expand-file-name "site-lisp/dot-org/dot-org.org" user-emacs-directory)))
  (when (file-exists-p org-config-file)
    (org-babel-load-file org-config-file nil)))
  #+end_src

* Solutions
** Find file as sudo
   Recently, I've had to edit a great deal of root-level files. This
   function will reopen a given file with superuser priviledges.
   #+begin_src emacs-lisp :tangle yes
(defun jr/reopen-as-sudo ()
  "Kill current buffer and open its file with augmented priviledges."
  (interactive)
  (let ((filename (buffer-file-name)))
    (unless filename
      (error "No file associated with current buffer."))
    (find-alternate-file (concat "/sudo::" filename))))

(bind-key "C-. s" 'jr/reopen-as-sudo)
   #+end_src
** Window splitting
   The following functions allow you to split and switch to a window at once.
   #+begin_src emacs-lisp :tangle yes
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(bind-key "C-x 2" 'vsplit-other-window)
(bind-key "C-x 3" 'hsplit-other-window)
   #+end_src
** Less intrusive visible bell
   #+begin_src emacs-lisp :tangle yes
(defun jr/flash-mode-line ()
  "Invert the mode-line face briefly.
This can be used as a friendlier visual bell effect.
Source: EmacsWiki"
  (invert-face 'mode-line)
  (run-with-timer 0.1 nil 'invert-face 'mode-line))

(setq visible-bell nil
      ring-bell-function #'jr/flash-mode-line)
   #+end_src
** PKGBUILD files
   #+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("PKGBUILD" . shell-script-mode))
   #+end_src
** Hungry delete
   #+begin_src emacs-lisp :tangle yes
(defun contextual-backspace ()
  "Hungry whitespace or delete word depending on context."
  (interactive)
  (if (looking-back "[[:space:]\n]\\{2,\\}" (- (point) 2))
      (while (looking-back "[[:space:]\n]" (- (point) 1))
        (delete-char -1))
    (cond
     ((and (boundp 'smartparens-strict-mode)
           smartparens-strict-mode)
      (sp-backward-kill-word 1))
     ((and (boundp 'subword-mode)
           subword-mode)
      (subword-backward-kill 1))
     (t
      (backward-kill-word 1)))))

(global-set-key (kbd "C-<backspace>") 'contextual-backspace)
   #+end_src
** Regex helpers
   #+begin_src emacs-lisp :tangle yes
(use-package re-builder
  :ensure nil
  ;; C-c C-u errors, C-c C-w copy, C-c C-q exit
  :init (bind-key "C-c r" 're-builder emacs-lisp-mode-map))

(use-package pcre2el
  :commands rxt-toggle-elisp-rx
  :init (bind-key "C-c / t" 'rxt-toggle-elisp-rx emacs-lisp-mode-map))

   #+end_src
** Indentation
   #+begin_src emacs-lisp :tangle yes
(defun indent-buffer ()
  "Indent the entire buffer."
  (interactive)
  (save-excursion
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max))))
   #+end_src
* Footer
  #+begin_src emacs-lisp :tangle yes
(message "Emacs config.el end")
  #+end_src
